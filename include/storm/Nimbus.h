/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Nimbus_H
#define Nimbus_H

#include <thrift/TDispatchProcessor.h>
#include "storm_types.h"



class NimbusIf {
 public:
  virtual ~NimbusIf() {}
  virtual void submitTopology(const std::string& name, const std::string& uploadedJarLocation, const std::string& jsonConf, const StormTopology& topology) = 0;
  virtual void submitTopologyWithOpts(const std::string& name, const std::string& uploadedJarLocation, const std::string& jsonConf, const StormTopology& topology, const SubmitOptions& options) = 0;
  virtual void killTopology(const std::string& name) = 0;
  virtual void killTopologyWithOpts(const std::string& name, const KillOptions& options) = 0;
  virtual void activate(const std::string& name) = 0;
  virtual void deactivate(const std::string& name) = 0;
  virtual void rebalance(const std::string& name, const RebalanceOptions& options) = 0;
  virtual void uploadNewCredentials(const std::string& name, const Credentials& creds) = 0;
  virtual void beginFileUpload(std::string& _return) = 0;
  virtual void uploadChunk(const std::string& location, const std::string& chunk) = 0;
  virtual void finishFileUpload(const std::string& location) = 0;
  virtual void beginFileDownload(std::string& _return, const std::string& file) = 0;
  virtual void downloadChunk(std::string& _return, const std::string& id) = 0;
  virtual void getNimbusConf(std::string& _return) = 0;
  virtual void getClusterInfo(ClusterSummary& _return) = 0;
  virtual void getTopologyInfo(TopologyInfo& _return, const std::string& id) = 0;
  virtual void getTopologyInfoWithOpts(TopologyInfo& _return, const std::string& id, const GetInfoOptions& options) = 0;
  virtual void getTopologyConf(std::string& _return, const std::string& id) = 0;

  /**
   * Returns the compiled topology that contains ackers and metrics consumsers. Compare {@link #getUserTopology(String id)}.
   * 
   * @param id
   */
  virtual void getTopology(StormTopology& _return, const std::string& id) = 0;

  /**
   * Returns the user specified topology as submitted originally. Compare {@link #getTopology(String id)}.
   * 
   * @param id
   */
  virtual void getUserTopology(StormTopology& _return, const std::string& id) = 0;
};

class NimbusIfFactory {
 public:
  typedef NimbusIf Handler;

  virtual ~NimbusIfFactory() {}

  virtual NimbusIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(NimbusIf* /* handler */) = 0;
};

class NimbusIfSingletonFactory : virtual public NimbusIfFactory {
 public:
  NimbusIfSingletonFactory(const boost::shared_ptr<NimbusIf>& iface) : iface_(iface) {}
  virtual ~NimbusIfSingletonFactory() {}

  virtual NimbusIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(NimbusIf* /* handler */) {}

 protected:
  boost::shared_ptr<NimbusIf> iface_;
};

class NimbusNull : virtual public NimbusIf {
 public:
  virtual ~NimbusNull() {}
  void submitTopology(const std::string& /* name */, const std::string& /* uploadedJarLocation */, const std::string& /* jsonConf */, const StormTopology& /* topology */) {
    return;
  }
  void submitTopologyWithOpts(const std::string& /* name */, const std::string& /* uploadedJarLocation */, const std::string& /* jsonConf */, const StormTopology& /* topology */, const SubmitOptions& /* options */) {
    return;
  }
  void killTopology(const std::string& /* name */) {
    return;
  }
  void killTopologyWithOpts(const std::string& /* name */, const KillOptions& /* options */) {
    return;
  }
  void activate(const std::string& /* name */) {
    return;
  }
  void deactivate(const std::string& /* name */) {
    return;
  }
  void rebalance(const std::string& /* name */, const RebalanceOptions& /* options */) {
    return;
  }
  void uploadNewCredentials(const std::string& /* name */, const Credentials& /* creds */) {
    return;
  }
  void beginFileUpload(std::string& /* _return */) {
    return;
  }
  void uploadChunk(const std::string& /* location */, const std::string& /* chunk */) {
    return;
  }
  void finishFileUpload(const std::string& /* location */) {
    return;
  }
  void beginFileDownload(std::string& /* _return */, const std::string& /* file */) {
    return;
  }
  void downloadChunk(std::string& /* _return */, const std::string& /* id */) {
    return;
  }
  void getNimbusConf(std::string& /* _return */) {
    return;
  }
  void getClusterInfo(ClusterSummary& /* _return */) {
    return;
  }
  void getTopologyInfo(TopologyInfo& /* _return */, const std::string& /* id */) {
    return;
  }
  void getTopologyInfoWithOpts(TopologyInfo& /* _return */, const std::string& /* id */, const GetInfoOptions& /* options */) {
    return;
  }
  void getTopologyConf(std::string& /* _return */, const std::string& /* id */) {
    return;
  }
  void getTopology(StormTopology& /* _return */, const std::string& /* id */) {
    return;
  }
  void getUserTopology(StormTopology& /* _return */, const std::string& /* id */) {
    return;
  }
};

typedef struct _Nimbus_submitTopology_args__isset {
  _Nimbus_submitTopology_args__isset() : name(false), uploadedJarLocation(false), jsonConf(false), topology(false) {}
  bool name :1;
  bool uploadedJarLocation :1;
  bool jsonConf :1;
  bool topology :1;
} _Nimbus_submitTopology_args__isset;

class Nimbus_submitTopology_args {
 public:

  static const char* ascii_fingerprint; // = "4C9CF727FA79D46DF50C8276041B3354";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x9C,0xF7,0x27,0xFA,0x79,0xD4,0x6D,0xF5,0x0C,0x82,0x76,0x04,0x1B,0x33,0x54};

  Nimbus_submitTopology_args(const Nimbus_submitTopology_args&);
  Nimbus_submitTopology_args& operator=(const Nimbus_submitTopology_args&);
  Nimbus_submitTopology_args() : name(), uploadedJarLocation(), jsonConf() {
  }

  virtual ~Nimbus_submitTopology_args() throw();
  std::string name;
  std::string uploadedJarLocation;
  std::string jsonConf;
  StormTopology topology;

  _Nimbus_submitTopology_args__isset __isset;

  void __set_name(const std::string& val);

  void __set_uploadedJarLocation(const std::string& val);

  void __set_jsonConf(const std::string& val);

  void __set_topology(const StormTopology& val);

  bool operator == (const Nimbus_submitTopology_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(uploadedJarLocation == rhs.uploadedJarLocation))
      return false;
    if (!(jsonConf == rhs.jsonConf))
      return false;
    if (!(topology == rhs.topology))
      return false;
    return true;
  }
  bool operator != (const Nimbus_submitTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_submitTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_submitTopology_args& obj);
};


class Nimbus_submitTopology_pargs {
 public:

  static const char* ascii_fingerprint; // = "4C9CF727FA79D46DF50C8276041B3354";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x9C,0xF7,0x27,0xFA,0x79,0xD4,0x6D,0xF5,0x0C,0x82,0x76,0x04,0x1B,0x33,0x54};


  virtual ~Nimbus_submitTopology_pargs() throw();
  const std::string* name;
  const std::string* uploadedJarLocation;
  const std::string* jsonConf;
  const StormTopology* topology;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_submitTopology_pargs& obj);
};

typedef struct _Nimbus_submitTopology_result__isset {
  _Nimbus_submitTopology_result__isset() : e(false), ite(false), aze(false) {}
  bool e :1;
  bool ite :1;
  bool aze :1;
} _Nimbus_submitTopology_result__isset;

class Nimbus_submitTopology_result {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};

  Nimbus_submitTopology_result(const Nimbus_submitTopology_result&);
  Nimbus_submitTopology_result& operator=(const Nimbus_submitTopology_result&);
  Nimbus_submitTopology_result() {
  }

  virtual ~Nimbus_submitTopology_result() throw();
  AlreadyAliveException e;
  InvalidTopologyException ite;
  AuthorizationException aze;

  _Nimbus_submitTopology_result__isset __isset;

  void __set_e(const AlreadyAliveException& val);

  void __set_ite(const InvalidTopologyException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_submitTopology_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    if (!(ite == rhs.ite))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_submitTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_submitTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_submitTopology_result& obj);
};

typedef struct _Nimbus_submitTopology_presult__isset {
  _Nimbus_submitTopology_presult__isset() : e(false), ite(false), aze(false) {}
  bool e :1;
  bool ite :1;
  bool aze :1;
} _Nimbus_submitTopology_presult__isset;

class Nimbus_submitTopology_presult {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};


  virtual ~Nimbus_submitTopology_presult() throw();
  AlreadyAliveException e;
  InvalidTopologyException ite;
  AuthorizationException aze;

  _Nimbus_submitTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_submitTopology_presult& obj);
};

typedef struct _Nimbus_submitTopologyWithOpts_args__isset {
  _Nimbus_submitTopologyWithOpts_args__isset() : name(false), uploadedJarLocation(false), jsonConf(false), topology(false), options(false) {}
  bool name :1;
  bool uploadedJarLocation :1;
  bool jsonConf :1;
  bool topology :1;
  bool options :1;
} _Nimbus_submitTopologyWithOpts_args__isset;

class Nimbus_submitTopologyWithOpts_args {
 public:

  static const char* ascii_fingerprint; // = "1810ABEE87721111CB8FAE2254205F06";
  static const uint8_t binary_fingerprint[16]; // = {0x18,0x10,0xAB,0xEE,0x87,0x72,0x11,0x11,0xCB,0x8F,0xAE,0x22,0x54,0x20,0x5F,0x06};

  Nimbus_submitTopologyWithOpts_args(const Nimbus_submitTopologyWithOpts_args&);
  Nimbus_submitTopologyWithOpts_args& operator=(const Nimbus_submitTopologyWithOpts_args&);
  Nimbus_submitTopologyWithOpts_args() : name(), uploadedJarLocation(), jsonConf() {
  }

  virtual ~Nimbus_submitTopologyWithOpts_args() throw();
  std::string name;
  std::string uploadedJarLocation;
  std::string jsonConf;
  StormTopology topology;
  SubmitOptions options;

  _Nimbus_submitTopologyWithOpts_args__isset __isset;

  void __set_name(const std::string& val);

  void __set_uploadedJarLocation(const std::string& val);

  void __set_jsonConf(const std::string& val);

  void __set_topology(const StormTopology& val);

  void __set_options(const SubmitOptions& val);

  bool operator == (const Nimbus_submitTopologyWithOpts_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(uploadedJarLocation == rhs.uploadedJarLocation))
      return false;
    if (!(jsonConf == rhs.jsonConf))
      return false;
    if (!(topology == rhs.topology))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const Nimbus_submitTopologyWithOpts_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_submitTopologyWithOpts_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_submitTopologyWithOpts_args& obj);
};


class Nimbus_submitTopologyWithOpts_pargs {
 public:

  static const char* ascii_fingerprint; // = "1810ABEE87721111CB8FAE2254205F06";
  static const uint8_t binary_fingerprint[16]; // = {0x18,0x10,0xAB,0xEE,0x87,0x72,0x11,0x11,0xCB,0x8F,0xAE,0x22,0x54,0x20,0x5F,0x06};


  virtual ~Nimbus_submitTopologyWithOpts_pargs() throw();
  const std::string* name;
  const std::string* uploadedJarLocation;
  const std::string* jsonConf;
  const StormTopology* topology;
  const SubmitOptions* options;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_submitTopologyWithOpts_pargs& obj);
};

typedef struct _Nimbus_submitTopologyWithOpts_result__isset {
  _Nimbus_submitTopologyWithOpts_result__isset() : e(false), ite(false), aze(false) {}
  bool e :1;
  bool ite :1;
  bool aze :1;
} _Nimbus_submitTopologyWithOpts_result__isset;

class Nimbus_submitTopologyWithOpts_result {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};

  Nimbus_submitTopologyWithOpts_result(const Nimbus_submitTopologyWithOpts_result&);
  Nimbus_submitTopologyWithOpts_result& operator=(const Nimbus_submitTopologyWithOpts_result&);
  Nimbus_submitTopologyWithOpts_result() {
  }

  virtual ~Nimbus_submitTopologyWithOpts_result() throw();
  AlreadyAliveException e;
  InvalidTopologyException ite;
  AuthorizationException aze;

  _Nimbus_submitTopologyWithOpts_result__isset __isset;

  void __set_e(const AlreadyAliveException& val);

  void __set_ite(const InvalidTopologyException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_submitTopologyWithOpts_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    if (!(ite == rhs.ite))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_submitTopologyWithOpts_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_submitTopologyWithOpts_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_submitTopologyWithOpts_result& obj);
};

typedef struct _Nimbus_submitTopologyWithOpts_presult__isset {
  _Nimbus_submitTopologyWithOpts_presult__isset() : e(false), ite(false), aze(false) {}
  bool e :1;
  bool ite :1;
  bool aze :1;
} _Nimbus_submitTopologyWithOpts_presult__isset;

class Nimbus_submitTopologyWithOpts_presult {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};


  virtual ~Nimbus_submitTopologyWithOpts_presult() throw();
  AlreadyAliveException e;
  InvalidTopologyException ite;
  AuthorizationException aze;

  _Nimbus_submitTopologyWithOpts_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_submitTopologyWithOpts_presult& obj);
};

typedef struct _Nimbus_killTopology_args__isset {
  _Nimbus_killTopology_args__isset() : name(false) {}
  bool name :1;
} _Nimbus_killTopology_args__isset;

class Nimbus_killTopology_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_killTopology_args(const Nimbus_killTopology_args&);
  Nimbus_killTopology_args& operator=(const Nimbus_killTopology_args&);
  Nimbus_killTopology_args() : name() {
  }

  virtual ~Nimbus_killTopology_args() throw();
  std::string name;

  _Nimbus_killTopology_args__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const Nimbus_killTopology_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Nimbus_killTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_killTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_killTopology_args& obj);
};


class Nimbus_killTopology_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_killTopology_pargs() throw();
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_killTopology_pargs& obj);
};

typedef struct _Nimbus_killTopology_result__isset {
  _Nimbus_killTopology_result__isset() : e(false), aze(false) {}
  bool e :1;
  bool aze :1;
} _Nimbus_killTopology_result__isset;

class Nimbus_killTopology_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Nimbus_killTopology_result(const Nimbus_killTopology_result&);
  Nimbus_killTopology_result& operator=(const Nimbus_killTopology_result&);
  Nimbus_killTopology_result() {
  }

  virtual ~Nimbus_killTopology_result() throw();
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_killTopology_result__isset __isset;

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_killTopology_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_killTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_killTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_killTopology_result& obj);
};

typedef struct _Nimbus_killTopology_presult__isset {
  _Nimbus_killTopology_presult__isset() : e(false), aze(false) {}
  bool e :1;
  bool aze :1;
} _Nimbus_killTopology_presult__isset;

class Nimbus_killTopology_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Nimbus_killTopology_presult() throw();
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_killTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_killTopology_presult& obj);
};

typedef struct _Nimbus_killTopologyWithOpts_args__isset {
  _Nimbus_killTopologyWithOpts_args__isset() : name(false), options(false) {}
  bool name :1;
  bool options :1;
} _Nimbus_killTopologyWithOpts_args__isset;

class Nimbus_killTopologyWithOpts_args {
 public:

  static const char* ascii_fingerprint; // = "8056B1BA9128BCC67DC4905F66F13CED";
  static const uint8_t binary_fingerprint[16]; // = {0x80,0x56,0xB1,0xBA,0x91,0x28,0xBC,0xC6,0x7D,0xC4,0x90,0x5F,0x66,0xF1,0x3C,0xED};

  Nimbus_killTopologyWithOpts_args(const Nimbus_killTopologyWithOpts_args&);
  Nimbus_killTopologyWithOpts_args& operator=(const Nimbus_killTopologyWithOpts_args&);
  Nimbus_killTopologyWithOpts_args() : name() {
  }

  virtual ~Nimbus_killTopologyWithOpts_args() throw();
  std::string name;
  KillOptions options;

  _Nimbus_killTopologyWithOpts_args__isset __isset;

  void __set_name(const std::string& val);

  void __set_options(const KillOptions& val);

  bool operator == (const Nimbus_killTopologyWithOpts_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const Nimbus_killTopologyWithOpts_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_killTopologyWithOpts_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_killTopologyWithOpts_args& obj);
};


class Nimbus_killTopologyWithOpts_pargs {
 public:

  static const char* ascii_fingerprint; // = "8056B1BA9128BCC67DC4905F66F13CED";
  static const uint8_t binary_fingerprint[16]; // = {0x80,0x56,0xB1,0xBA,0x91,0x28,0xBC,0xC6,0x7D,0xC4,0x90,0x5F,0x66,0xF1,0x3C,0xED};


  virtual ~Nimbus_killTopologyWithOpts_pargs() throw();
  const std::string* name;
  const KillOptions* options;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_killTopologyWithOpts_pargs& obj);
};

typedef struct _Nimbus_killTopologyWithOpts_result__isset {
  _Nimbus_killTopologyWithOpts_result__isset() : e(false), aze(false) {}
  bool e :1;
  bool aze :1;
} _Nimbus_killTopologyWithOpts_result__isset;

class Nimbus_killTopologyWithOpts_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Nimbus_killTopologyWithOpts_result(const Nimbus_killTopologyWithOpts_result&);
  Nimbus_killTopologyWithOpts_result& operator=(const Nimbus_killTopologyWithOpts_result&);
  Nimbus_killTopologyWithOpts_result() {
  }

  virtual ~Nimbus_killTopologyWithOpts_result() throw();
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_killTopologyWithOpts_result__isset __isset;

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_killTopologyWithOpts_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_killTopologyWithOpts_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_killTopologyWithOpts_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_killTopologyWithOpts_result& obj);
};

typedef struct _Nimbus_killTopologyWithOpts_presult__isset {
  _Nimbus_killTopologyWithOpts_presult__isset() : e(false), aze(false) {}
  bool e :1;
  bool aze :1;
} _Nimbus_killTopologyWithOpts_presult__isset;

class Nimbus_killTopologyWithOpts_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Nimbus_killTopologyWithOpts_presult() throw();
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_killTopologyWithOpts_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_killTopologyWithOpts_presult& obj);
};

typedef struct _Nimbus_activate_args__isset {
  _Nimbus_activate_args__isset() : name(false) {}
  bool name :1;
} _Nimbus_activate_args__isset;

class Nimbus_activate_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_activate_args(const Nimbus_activate_args&);
  Nimbus_activate_args& operator=(const Nimbus_activate_args&);
  Nimbus_activate_args() : name() {
  }

  virtual ~Nimbus_activate_args() throw();
  std::string name;

  _Nimbus_activate_args__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const Nimbus_activate_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Nimbus_activate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_activate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_activate_args& obj);
};


class Nimbus_activate_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_activate_pargs() throw();
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_activate_pargs& obj);
};

typedef struct _Nimbus_activate_result__isset {
  _Nimbus_activate_result__isset() : e(false), aze(false) {}
  bool e :1;
  bool aze :1;
} _Nimbus_activate_result__isset;

class Nimbus_activate_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Nimbus_activate_result(const Nimbus_activate_result&);
  Nimbus_activate_result& operator=(const Nimbus_activate_result&);
  Nimbus_activate_result() {
  }

  virtual ~Nimbus_activate_result() throw();
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_activate_result__isset __isset;

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_activate_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_activate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_activate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_activate_result& obj);
};

typedef struct _Nimbus_activate_presult__isset {
  _Nimbus_activate_presult__isset() : e(false), aze(false) {}
  bool e :1;
  bool aze :1;
} _Nimbus_activate_presult__isset;

class Nimbus_activate_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Nimbus_activate_presult() throw();
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_activate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_activate_presult& obj);
};

typedef struct _Nimbus_deactivate_args__isset {
  _Nimbus_deactivate_args__isset() : name(false) {}
  bool name :1;
} _Nimbus_deactivate_args__isset;

class Nimbus_deactivate_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_deactivate_args(const Nimbus_deactivate_args&);
  Nimbus_deactivate_args& operator=(const Nimbus_deactivate_args&);
  Nimbus_deactivate_args() : name() {
  }

  virtual ~Nimbus_deactivate_args() throw();
  std::string name;

  _Nimbus_deactivate_args__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const Nimbus_deactivate_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Nimbus_deactivate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_deactivate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_deactivate_args& obj);
};


class Nimbus_deactivate_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_deactivate_pargs() throw();
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_deactivate_pargs& obj);
};

typedef struct _Nimbus_deactivate_result__isset {
  _Nimbus_deactivate_result__isset() : e(false), aze(false) {}
  bool e :1;
  bool aze :1;
} _Nimbus_deactivate_result__isset;

class Nimbus_deactivate_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Nimbus_deactivate_result(const Nimbus_deactivate_result&);
  Nimbus_deactivate_result& operator=(const Nimbus_deactivate_result&);
  Nimbus_deactivate_result() {
  }

  virtual ~Nimbus_deactivate_result() throw();
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_deactivate_result__isset __isset;

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_deactivate_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_deactivate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_deactivate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_deactivate_result& obj);
};

typedef struct _Nimbus_deactivate_presult__isset {
  _Nimbus_deactivate_presult__isset() : e(false), aze(false) {}
  bool e :1;
  bool aze :1;
} _Nimbus_deactivate_presult__isset;

class Nimbus_deactivate_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Nimbus_deactivate_presult() throw();
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_deactivate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_deactivate_presult& obj);
};

typedef struct _Nimbus_rebalance_args__isset {
  _Nimbus_rebalance_args__isset() : name(false), options(false) {}
  bool name :1;
  bool options :1;
} _Nimbus_rebalance_args__isset;

class Nimbus_rebalance_args {
 public:

  static const char* ascii_fingerprint; // = "7BBFD6B8ACC613A5FE64041787906AFF";
  static const uint8_t binary_fingerprint[16]; // = {0x7B,0xBF,0xD6,0xB8,0xAC,0xC6,0x13,0xA5,0xFE,0x64,0x04,0x17,0x87,0x90,0x6A,0xFF};

  Nimbus_rebalance_args(const Nimbus_rebalance_args&);
  Nimbus_rebalance_args& operator=(const Nimbus_rebalance_args&);
  Nimbus_rebalance_args() : name() {
  }

  virtual ~Nimbus_rebalance_args() throw();
  std::string name;
  RebalanceOptions options;

  _Nimbus_rebalance_args__isset __isset;

  void __set_name(const std::string& val);

  void __set_options(const RebalanceOptions& val);

  bool operator == (const Nimbus_rebalance_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const Nimbus_rebalance_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_rebalance_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_rebalance_args& obj);
};


class Nimbus_rebalance_pargs {
 public:

  static const char* ascii_fingerprint; // = "7BBFD6B8ACC613A5FE64041787906AFF";
  static const uint8_t binary_fingerprint[16]; // = {0x7B,0xBF,0xD6,0xB8,0xAC,0xC6,0x13,0xA5,0xFE,0x64,0x04,0x17,0x87,0x90,0x6A,0xFF};


  virtual ~Nimbus_rebalance_pargs() throw();
  const std::string* name;
  const RebalanceOptions* options;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_rebalance_pargs& obj);
};

typedef struct _Nimbus_rebalance_result__isset {
  _Nimbus_rebalance_result__isset() : e(false), ite(false), aze(false) {}
  bool e :1;
  bool ite :1;
  bool aze :1;
} _Nimbus_rebalance_result__isset;

class Nimbus_rebalance_result {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};

  Nimbus_rebalance_result(const Nimbus_rebalance_result&);
  Nimbus_rebalance_result& operator=(const Nimbus_rebalance_result&);
  Nimbus_rebalance_result() {
  }

  virtual ~Nimbus_rebalance_result() throw();
  NotAliveException e;
  InvalidTopologyException ite;
  AuthorizationException aze;

  _Nimbus_rebalance_result__isset __isset;

  void __set_e(const NotAliveException& val);

  void __set_ite(const InvalidTopologyException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_rebalance_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    if (!(ite == rhs.ite))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_rebalance_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_rebalance_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_rebalance_result& obj);
};

typedef struct _Nimbus_rebalance_presult__isset {
  _Nimbus_rebalance_presult__isset() : e(false), ite(false), aze(false) {}
  bool e :1;
  bool ite :1;
  bool aze :1;
} _Nimbus_rebalance_presult__isset;

class Nimbus_rebalance_presult {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};


  virtual ~Nimbus_rebalance_presult() throw();
  NotAliveException e;
  InvalidTopologyException ite;
  AuthorizationException aze;

  _Nimbus_rebalance_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_rebalance_presult& obj);
};

typedef struct _Nimbus_uploadNewCredentials_args__isset {
  _Nimbus_uploadNewCredentials_args__isset() : name(false), creds(false) {}
  bool name :1;
  bool creds :1;
} _Nimbus_uploadNewCredentials_args__isset;

class Nimbus_uploadNewCredentials_args {
 public:

  static const char* ascii_fingerprint; // = "1BE976FD0DACD29BFAF87AFC7A82EC6F";
  static const uint8_t binary_fingerprint[16]; // = {0x1B,0xE9,0x76,0xFD,0x0D,0xAC,0xD2,0x9B,0xFA,0xF8,0x7A,0xFC,0x7A,0x82,0xEC,0x6F};

  Nimbus_uploadNewCredentials_args(const Nimbus_uploadNewCredentials_args&);
  Nimbus_uploadNewCredentials_args& operator=(const Nimbus_uploadNewCredentials_args&);
  Nimbus_uploadNewCredentials_args() : name() {
  }

  virtual ~Nimbus_uploadNewCredentials_args() throw();
  std::string name;
  Credentials creds;

  _Nimbus_uploadNewCredentials_args__isset __isset;

  void __set_name(const std::string& val);

  void __set_creds(const Credentials& val);

  bool operator == (const Nimbus_uploadNewCredentials_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(creds == rhs.creds))
      return false;
    return true;
  }
  bool operator != (const Nimbus_uploadNewCredentials_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_uploadNewCredentials_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_uploadNewCredentials_args& obj);
};


class Nimbus_uploadNewCredentials_pargs {
 public:

  static const char* ascii_fingerprint; // = "1BE976FD0DACD29BFAF87AFC7A82EC6F";
  static const uint8_t binary_fingerprint[16]; // = {0x1B,0xE9,0x76,0xFD,0x0D,0xAC,0xD2,0x9B,0xFA,0xF8,0x7A,0xFC,0x7A,0x82,0xEC,0x6F};


  virtual ~Nimbus_uploadNewCredentials_pargs() throw();
  const std::string* name;
  const Credentials* creds;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_uploadNewCredentials_pargs& obj);
};

typedef struct _Nimbus_uploadNewCredentials_result__isset {
  _Nimbus_uploadNewCredentials_result__isset() : e(false), ite(false), aze(false) {}
  bool e :1;
  bool ite :1;
  bool aze :1;
} _Nimbus_uploadNewCredentials_result__isset;

class Nimbus_uploadNewCredentials_result {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};

  Nimbus_uploadNewCredentials_result(const Nimbus_uploadNewCredentials_result&);
  Nimbus_uploadNewCredentials_result& operator=(const Nimbus_uploadNewCredentials_result&);
  Nimbus_uploadNewCredentials_result() {
  }

  virtual ~Nimbus_uploadNewCredentials_result() throw();
  NotAliveException e;
  InvalidTopologyException ite;
  AuthorizationException aze;

  _Nimbus_uploadNewCredentials_result__isset __isset;

  void __set_e(const NotAliveException& val);

  void __set_ite(const InvalidTopologyException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_uploadNewCredentials_result & rhs) const
  {
    if (!(e == rhs.e))
      return false;
    if (!(ite == rhs.ite))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_uploadNewCredentials_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_uploadNewCredentials_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_uploadNewCredentials_result& obj);
};

typedef struct _Nimbus_uploadNewCredentials_presult__isset {
  _Nimbus_uploadNewCredentials_presult__isset() : e(false), ite(false), aze(false) {}
  bool e :1;
  bool ite :1;
  bool aze :1;
} _Nimbus_uploadNewCredentials_presult__isset;

class Nimbus_uploadNewCredentials_presult {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};


  virtual ~Nimbus_uploadNewCredentials_presult() throw();
  NotAliveException e;
  InvalidTopologyException ite;
  AuthorizationException aze;

  _Nimbus_uploadNewCredentials_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_uploadNewCredentials_presult& obj);
};


class Nimbus_beginFileUpload_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Nimbus_beginFileUpload_args(const Nimbus_beginFileUpload_args&);
  Nimbus_beginFileUpload_args& operator=(const Nimbus_beginFileUpload_args&);
  Nimbus_beginFileUpload_args() {
  }

  virtual ~Nimbus_beginFileUpload_args() throw();

  bool operator == (const Nimbus_beginFileUpload_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Nimbus_beginFileUpload_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_beginFileUpload_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_beginFileUpload_args& obj);
};


class Nimbus_beginFileUpload_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Nimbus_beginFileUpload_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_beginFileUpload_pargs& obj);
};

typedef struct _Nimbus_beginFileUpload_result__isset {
  _Nimbus_beginFileUpload_result__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_beginFileUpload_result__isset;

class Nimbus_beginFileUpload_result {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};

  Nimbus_beginFileUpload_result(const Nimbus_beginFileUpload_result&);
  Nimbus_beginFileUpload_result& operator=(const Nimbus_beginFileUpload_result&);
  Nimbus_beginFileUpload_result() : success() {
  }

  virtual ~Nimbus_beginFileUpload_result() throw();
  std::string success;
  AuthorizationException aze;

  _Nimbus_beginFileUpload_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_beginFileUpload_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_beginFileUpload_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_beginFileUpload_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_beginFileUpload_result& obj);
};

typedef struct _Nimbus_beginFileUpload_presult__isset {
  _Nimbus_beginFileUpload_presult__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_beginFileUpload_presult__isset;

class Nimbus_beginFileUpload_presult {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};


  virtual ~Nimbus_beginFileUpload_presult() throw();
  std::string* success;
  AuthorizationException aze;

  _Nimbus_beginFileUpload_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_beginFileUpload_presult& obj);
};

typedef struct _Nimbus_uploadChunk_args__isset {
  _Nimbus_uploadChunk_args__isset() : location(false), chunk(false) {}
  bool location :1;
  bool chunk :1;
} _Nimbus_uploadChunk_args__isset;

class Nimbus_uploadChunk_args {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Nimbus_uploadChunk_args(const Nimbus_uploadChunk_args&);
  Nimbus_uploadChunk_args& operator=(const Nimbus_uploadChunk_args&);
  Nimbus_uploadChunk_args() : location(), chunk() {
  }

  virtual ~Nimbus_uploadChunk_args() throw();
  std::string location;
  std::string chunk;

  _Nimbus_uploadChunk_args__isset __isset;

  void __set_location(const std::string& val);

  void __set_chunk(const std::string& val);

  bool operator == (const Nimbus_uploadChunk_args & rhs) const
  {
    if (!(location == rhs.location))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    return true;
  }
  bool operator != (const Nimbus_uploadChunk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_uploadChunk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_uploadChunk_args& obj);
};


class Nimbus_uploadChunk_pargs {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};


  virtual ~Nimbus_uploadChunk_pargs() throw();
  const std::string* location;
  const std::string* chunk;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_uploadChunk_pargs& obj);
};

typedef struct _Nimbus_uploadChunk_result__isset {
  _Nimbus_uploadChunk_result__isset() : aze(false) {}
  bool aze :1;
} _Nimbus_uploadChunk_result__isset;

class Nimbus_uploadChunk_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Nimbus_uploadChunk_result(const Nimbus_uploadChunk_result&);
  Nimbus_uploadChunk_result& operator=(const Nimbus_uploadChunk_result&);
  Nimbus_uploadChunk_result() {
  }

  virtual ~Nimbus_uploadChunk_result() throw();
  AuthorizationException aze;

  _Nimbus_uploadChunk_result__isset __isset;

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_uploadChunk_result & rhs) const
  {
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_uploadChunk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_uploadChunk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_uploadChunk_result& obj);
};

typedef struct _Nimbus_uploadChunk_presult__isset {
  _Nimbus_uploadChunk_presult__isset() : aze(false) {}
  bool aze :1;
} _Nimbus_uploadChunk_presult__isset;

class Nimbus_uploadChunk_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Nimbus_uploadChunk_presult() throw();
  AuthorizationException aze;

  _Nimbus_uploadChunk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_uploadChunk_presult& obj);
};

typedef struct _Nimbus_finishFileUpload_args__isset {
  _Nimbus_finishFileUpload_args__isset() : location(false) {}
  bool location :1;
} _Nimbus_finishFileUpload_args__isset;

class Nimbus_finishFileUpload_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_finishFileUpload_args(const Nimbus_finishFileUpload_args&);
  Nimbus_finishFileUpload_args& operator=(const Nimbus_finishFileUpload_args&);
  Nimbus_finishFileUpload_args() : location() {
  }

  virtual ~Nimbus_finishFileUpload_args() throw();
  std::string location;

  _Nimbus_finishFileUpload_args__isset __isset;

  void __set_location(const std::string& val);

  bool operator == (const Nimbus_finishFileUpload_args & rhs) const
  {
    if (!(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const Nimbus_finishFileUpload_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_finishFileUpload_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_finishFileUpload_args& obj);
};


class Nimbus_finishFileUpload_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_finishFileUpload_pargs() throw();
  const std::string* location;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_finishFileUpload_pargs& obj);
};

typedef struct _Nimbus_finishFileUpload_result__isset {
  _Nimbus_finishFileUpload_result__isset() : aze(false) {}
  bool aze :1;
} _Nimbus_finishFileUpload_result__isset;

class Nimbus_finishFileUpload_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Nimbus_finishFileUpload_result(const Nimbus_finishFileUpload_result&);
  Nimbus_finishFileUpload_result& operator=(const Nimbus_finishFileUpload_result&);
  Nimbus_finishFileUpload_result() {
  }

  virtual ~Nimbus_finishFileUpload_result() throw();
  AuthorizationException aze;

  _Nimbus_finishFileUpload_result__isset __isset;

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_finishFileUpload_result & rhs) const
  {
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_finishFileUpload_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_finishFileUpload_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_finishFileUpload_result& obj);
};

typedef struct _Nimbus_finishFileUpload_presult__isset {
  _Nimbus_finishFileUpload_presult__isset() : aze(false) {}
  bool aze :1;
} _Nimbus_finishFileUpload_presult__isset;

class Nimbus_finishFileUpload_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Nimbus_finishFileUpload_presult() throw();
  AuthorizationException aze;

  _Nimbus_finishFileUpload_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_finishFileUpload_presult& obj);
};

typedef struct _Nimbus_beginFileDownload_args__isset {
  _Nimbus_beginFileDownload_args__isset() : file(false) {}
  bool file :1;
} _Nimbus_beginFileDownload_args__isset;

class Nimbus_beginFileDownload_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_beginFileDownload_args(const Nimbus_beginFileDownload_args&);
  Nimbus_beginFileDownload_args& operator=(const Nimbus_beginFileDownload_args&);
  Nimbus_beginFileDownload_args() : file() {
  }

  virtual ~Nimbus_beginFileDownload_args() throw();
  std::string file;

  _Nimbus_beginFileDownload_args__isset __isset;

  void __set_file(const std::string& val);

  bool operator == (const Nimbus_beginFileDownload_args & rhs) const
  {
    if (!(file == rhs.file))
      return false;
    return true;
  }
  bool operator != (const Nimbus_beginFileDownload_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_beginFileDownload_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_beginFileDownload_args& obj);
};


class Nimbus_beginFileDownload_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_beginFileDownload_pargs() throw();
  const std::string* file;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_beginFileDownload_pargs& obj);
};

typedef struct _Nimbus_beginFileDownload_result__isset {
  _Nimbus_beginFileDownload_result__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_beginFileDownload_result__isset;

class Nimbus_beginFileDownload_result {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};

  Nimbus_beginFileDownload_result(const Nimbus_beginFileDownload_result&);
  Nimbus_beginFileDownload_result& operator=(const Nimbus_beginFileDownload_result&);
  Nimbus_beginFileDownload_result() : success() {
  }

  virtual ~Nimbus_beginFileDownload_result() throw();
  std::string success;
  AuthorizationException aze;

  _Nimbus_beginFileDownload_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_beginFileDownload_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_beginFileDownload_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_beginFileDownload_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_beginFileDownload_result& obj);
};

typedef struct _Nimbus_beginFileDownload_presult__isset {
  _Nimbus_beginFileDownload_presult__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_beginFileDownload_presult__isset;

class Nimbus_beginFileDownload_presult {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};


  virtual ~Nimbus_beginFileDownload_presult() throw();
  std::string* success;
  AuthorizationException aze;

  _Nimbus_beginFileDownload_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_beginFileDownload_presult& obj);
};

typedef struct _Nimbus_downloadChunk_args__isset {
  _Nimbus_downloadChunk_args__isset() : id(false) {}
  bool id :1;
} _Nimbus_downloadChunk_args__isset;

class Nimbus_downloadChunk_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_downloadChunk_args(const Nimbus_downloadChunk_args&);
  Nimbus_downloadChunk_args& operator=(const Nimbus_downloadChunk_args&);
  Nimbus_downloadChunk_args() : id() {
  }

  virtual ~Nimbus_downloadChunk_args() throw();
  std::string id;

  _Nimbus_downloadChunk_args__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const Nimbus_downloadChunk_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Nimbus_downloadChunk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_downloadChunk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_downloadChunk_args& obj);
};


class Nimbus_downloadChunk_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_downloadChunk_pargs() throw();
  const std::string* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_downloadChunk_pargs& obj);
};

typedef struct _Nimbus_downloadChunk_result__isset {
  _Nimbus_downloadChunk_result__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_downloadChunk_result__isset;

class Nimbus_downloadChunk_result {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};

  Nimbus_downloadChunk_result(const Nimbus_downloadChunk_result&);
  Nimbus_downloadChunk_result& operator=(const Nimbus_downloadChunk_result&);
  Nimbus_downloadChunk_result() : success() {
  }

  virtual ~Nimbus_downloadChunk_result() throw();
  std::string success;
  AuthorizationException aze;

  _Nimbus_downloadChunk_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_downloadChunk_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_downloadChunk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_downloadChunk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_downloadChunk_result& obj);
};

typedef struct _Nimbus_downloadChunk_presult__isset {
  _Nimbus_downloadChunk_presult__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_downloadChunk_presult__isset;

class Nimbus_downloadChunk_presult {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};


  virtual ~Nimbus_downloadChunk_presult() throw();
  std::string* success;
  AuthorizationException aze;

  _Nimbus_downloadChunk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_downloadChunk_presult& obj);
};


class Nimbus_getNimbusConf_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Nimbus_getNimbusConf_args(const Nimbus_getNimbusConf_args&);
  Nimbus_getNimbusConf_args& operator=(const Nimbus_getNimbusConf_args&);
  Nimbus_getNimbusConf_args() {
  }

  virtual ~Nimbus_getNimbusConf_args() throw();

  bool operator == (const Nimbus_getNimbusConf_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Nimbus_getNimbusConf_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getNimbusConf_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getNimbusConf_args& obj);
};


class Nimbus_getNimbusConf_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Nimbus_getNimbusConf_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getNimbusConf_pargs& obj);
};

typedef struct _Nimbus_getNimbusConf_result__isset {
  _Nimbus_getNimbusConf_result__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_getNimbusConf_result__isset;

class Nimbus_getNimbusConf_result {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};

  Nimbus_getNimbusConf_result(const Nimbus_getNimbusConf_result&);
  Nimbus_getNimbusConf_result& operator=(const Nimbus_getNimbusConf_result&);
  Nimbus_getNimbusConf_result() : success() {
  }

  virtual ~Nimbus_getNimbusConf_result() throw();
  std::string success;
  AuthorizationException aze;

  _Nimbus_getNimbusConf_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_getNimbusConf_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getNimbusConf_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getNimbusConf_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getNimbusConf_result& obj);
};

typedef struct _Nimbus_getNimbusConf_presult__isset {
  _Nimbus_getNimbusConf_presult__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_getNimbusConf_presult__isset;

class Nimbus_getNimbusConf_presult {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};


  virtual ~Nimbus_getNimbusConf_presult() throw();
  std::string* success;
  AuthorizationException aze;

  _Nimbus_getNimbusConf_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getNimbusConf_presult& obj);
};


class Nimbus_getClusterInfo_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Nimbus_getClusterInfo_args(const Nimbus_getClusterInfo_args&);
  Nimbus_getClusterInfo_args& operator=(const Nimbus_getClusterInfo_args&);
  Nimbus_getClusterInfo_args() {
  }

  virtual ~Nimbus_getClusterInfo_args() throw();

  bool operator == (const Nimbus_getClusterInfo_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Nimbus_getClusterInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getClusterInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getClusterInfo_args& obj);
};


class Nimbus_getClusterInfo_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Nimbus_getClusterInfo_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getClusterInfo_pargs& obj);
};

typedef struct _Nimbus_getClusterInfo_result__isset {
  _Nimbus_getClusterInfo_result__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_getClusterInfo_result__isset;

class Nimbus_getClusterInfo_result {
 public:

  static const char* ascii_fingerprint; // = "77A2F40389EAACA690F3FB3F935984FA";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0xA2,0xF4,0x03,0x89,0xEA,0xAC,0xA6,0x90,0xF3,0xFB,0x3F,0x93,0x59,0x84,0xFA};

  Nimbus_getClusterInfo_result(const Nimbus_getClusterInfo_result&);
  Nimbus_getClusterInfo_result& operator=(const Nimbus_getClusterInfo_result&);
  Nimbus_getClusterInfo_result() {
  }

  virtual ~Nimbus_getClusterInfo_result() throw();
  ClusterSummary success;
  AuthorizationException aze;

  _Nimbus_getClusterInfo_result__isset __isset;

  void __set_success(const ClusterSummary& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_getClusterInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getClusterInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getClusterInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getClusterInfo_result& obj);
};

typedef struct _Nimbus_getClusterInfo_presult__isset {
  _Nimbus_getClusterInfo_presult__isset() : success(false), aze(false) {}
  bool success :1;
  bool aze :1;
} _Nimbus_getClusterInfo_presult__isset;

class Nimbus_getClusterInfo_presult {
 public:

  static const char* ascii_fingerprint; // = "77A2F40389EAACA690F3FB3F935984FA";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0xA2,0xF4,0x03,0x89,0xEA,0xAC,0xA6,0x90,0xF3,0xFB,0x3F,0x93,0x59,0x84,0xFA};


  virtual ~Nimbus_getClusterInfo_presult() throw();
  ClusterSummary* success;
  AuthorizationException aze;

  _Nimbus_getClusterInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getClusterInfo_presult& obj);
};

typedef struct _Nimbus_getTopologyInfo_args__isset {
  _Nimbus_getTopologyInfo_args__isset() : id(false) {}
  bool id :1;
} _Nimbus_getTopologyInfo_args__isset;

class Nimbus_getTopologyInfo_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_getTopologyInfo_args(const Nimbus_getTopologyInfo_args&);
  Nimbus_getTopologyInfo_args& operator=(const Nimbus_getTopologyInfo_args&);
  Nimbus_getTopologyInfo_args() : id() {
  }

  virtual ~Nimbus_getTopologyInfo_args() throw();
  std::string id;

  _Nimbus_getTopologyInfo_args__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const Nimbus_getTopologyInfo_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getTopologyInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getTopologyInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyInfo_args& obj);
};


class Nimbus_getTopologyInfo_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_getTopologyInfo_pargs() throw();
  const std::string* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyInfo_pargs& obj);
};

typedef struct _Nimbus_getTopologyInfo_result__isset {
  _Nimbus_getTopologyInfo_result__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getTopologyInfo_result__isset;

class Nimbus_getTopologyInfo_result {
 public:

  static const char* ascii_fingerprint; // = "D751F187E3052A2F50D5B07A36B5EEE1";
  static const uint8_t binary_fingerprint[16]; // = {0xD7,0x51,0xF1,0x87,0xE3,0x05,0x2A,0x2F,0x50,0xD5,0xB0,0x7A,0x36,0xB5,0xEE,0xE1};

  Nimbus_getTopologyInfo_result(const Nimbus_getTopologyInfo_result&);
  Nimbus_getTopologyInfo_result& operator=(const Nimbus_getTopologyInfo_result&);
  Nimbus_getTopologyInfo_result() {
  }

  virtual ~Nimbus_getTopologyInfo_result() throw();
  TopologyInfo success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getTopologyInfo_result__isset __isset;

  void __set_success(const TopologyInfo& val);

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_getTopologyInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getTopologyInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getTopologyInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyInfo_result& obj);
};

typedef struct _Nimbus_getTopologyInfo_presult__isset {
  _Nimbus_getTopologyInfo_presult__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getTopologyInfo_presult__isset;

class Nimbus_getTopologyInfo_presult {
 public:

  static const char* ascii_fingerprint; // = "D751F187E3052A2F50D5B07A36B5EEE1";
  static const uint8_t binary_fingerprint[16]; // = {0xD7,0x51,0xF1,0x87,0xE3,0x05,0x2A,0x2F,0x50,0xD5,0xB0,0x7A,0x36,0xB5,0xEE,0xE1};


  virtual ~Nimbus_getTopologyInfo_presult() throw();
  TopologyInfo* success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getTopologyInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyInfo_presult& obj);
};

typedef struct _Nimbus_getTopologyInfoWithOpts_args__isset {
  _Nimbus_getTopologyInfoWithOpts_args__isset() : id(false), options(false) {}
  bool id :1;
  bool options :1;
} _Nimbus_getTopologyInfoWithOpts_args__isset;

class Nimbus_getTopologyInfoWithOpts_args {
 public:

  static const char* ascii_fingerprint; // = "2FAB0EF0081FA349B44FA593E61C436B";
  static const uint8_t binary_fingerprint[16]; // = {0x2F,0xAB,0x0E,0xF0,0x08,0x1F,0xA3,0x49,0xB4,0x4F,0xA5,0x93,0xE6,0x1C,0x43,0x6B};

  Nimbus_getTopologyInfoWithOpts_args(const Nimbus_getTopologyInfoWithOpts_args&);
  Nimbus_getTopologyInfoWithOpts_args& operator=(const Nimbus_getTopologyInfoWithOpts_args&);
  Nimbus_getTopologyInfoWithOpts_args() : id() {
  }

  virtual ~Nimbus_getTopologyInfoWithOpts_args() throw();
  std::string id;
  GetInfoOptions options;

  _Nimbus_getTopologyInfoWithOpts_args__isset __isset;

  void __set_id(const std::string& val);

  void __set_options(const GetInfoOptions& val);

  bool operator == (const Nimbus_getTopologyInfoWithOpts_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getTopologyInfoWithOpts_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getTopologyInfoWithOpts_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyInfoWithOpts_args& obj);
};


class Nimbus_getTopologyInfoWithOpts_pargs {
 public:

  static const char* ascii_fingerprint; // = "2FAB0EF0081FA349B44FA593E61C436B";
  static const uint8_t binary_fingerprint[16]; // = {0x2F,0xAB,0x0E,0xF0,0x08,0x1F,0xA3,0x49,0xB4,0x4F,0xA5,0x93,0xE6,0x1C,0x43,0x6B};


  virtual ~Nimbus_getTopologyInfoWithOpts_pargs() throw();
  const std::string* id;
  const GetInfoOptions* options;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyInfoWithOpts_pargs& obj);
};

typedef struct _Nimbus_getTopologyInfoWithOpts_result__isset {
  _Nimbus_getTopologyInfoWithOpts_result__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getTopologyInfoWithOpts_result__isset;

class Nimbus_getTopologyInfoWithOpts_result {
 public:

  static const char* ascii_fingerprint; // = "D751F187E3052A2F50D5B07A36B5EEE1";
  static const uint8_t binary_fingerprint[16]; // = {0xD7,0x51,0xF1,0x87,0xE3,0x05,0x2A,0x2F,0x50,0xD5,0xB0,0x7A,0x36,0xB5,0xEE,0xE1};

  Nimbus_getTopologyInfoWithOpts_result(const Nimbus_getTopologyInfoWithOpts_result&);
  Nimbus_getTopologyInfoWithOpts_result& operator=(const Nimbus_getTopologyInfoWithOpts_result&);
  Nimbus_getTopologyInfoWithOpts_result() {
  }

  virtual ~Nimbus_getTopologyInfoWithOpts_result() throw();
  TopologyInfo success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getTopologyInfoWithOpts_result__isset __isset;

  void __set_success(const TopologyInfo& val);

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_getTopologyInfoWithOpts_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getTopologyInfoWithOpts_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getTopologyInfoWithOpts_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyInfoWithOpts_result& obj);
};

typedef struct _Nimbus_getTopologyInfoWithOpts_presult__isset {
  _Nimbus_getTopologyInfoWithOpts_presult__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getTopologyInfoWithOpts_presult__isset;

class Nimbus_getTopologyInfoWithOpts_presult {
 public:

  static const char* ascii_fingerprint; // = "D751F187E3052A2F50D5B07A36B5EEE1";
  static const uint8_t binary_fingerprint[16]; // = {0xD7,0x51,0xF1,0x87,0xE3,0x05,0x2A,0x2F,0x50,0xD5,0xB0,0x7A,0x36,0xB5,0xEE,0xE1};


  virtual ~Nimbus_getTopologyInfoWithOpts_presult() throw();
  TopologyInfo* success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getTopologyInfoWithOpts_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyInfoWithOpts_presult& obj);
};

typedef struct _Nimbus_getTopologyConf_args__isset {
  _Nimbus_getTopologyConf_args__isset() : id(false) {}
  bool id :1;
} _Nimbus_getTopologyConf_args__isset;

class Nimbus_getTopologyConf_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_getTopologyConf_args(const Nimbus_getTopologyConf_args&);
  Nimbus_getTopologyConf_args& operator=(const Nimbus_getTopologyConf_args&);
  Nimbus_getTopologyConf_args() : id() {
  }

  virtual ~Nimbus_getTopologyConf_args() throw();
  std::string id;

  _Nimbus_getTopologyConf_args__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const Nimbus_getTopologyConf_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getTopologyConf_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getTopologyConf_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyConf_args& obj);
};


class Nimbus_getTopologyConf_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_getTopologyConf_pargs() throw();
  const std::string* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyConf_pargs& obj);
};

typedef struct _Nimbus_getTopologyConf_result__isset {
  _Nimbus_getTopologyConf_result__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getTopologyConf_result__isset;

class Nimbus_getTopologyConf_result {
 public:

  static const char* ascii_fingerprint; // = "49854EEF51738863052F2475D0A9B6AD";
  static const uint8_t binary_fingerprint[16]; // = {0x49,0x85,0x4E,0xEF,0x51,0x73,0x88,0x63,0x05,0x2F,0x24,0x75,0xD0,0xA9,0xB6,0xAD};

  Nimbus_getTopologyConf_result(const Nimbus_getTopologyConf_result&);
  Nimbus_getTopologyConf_result& operator=(const Nimbus_getTopologyConf_result&);
  Nimbus_getTopologyConf_result() : success() {
  }

  virtual ~Nimbus_getTopologyConf_result() throw();
  std::string success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getTopologyConf_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_getTopologyConf_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getTopologyConf_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getTopologyConf_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyConf_result& obj);
};

typedef struct _Nimbus_getTopologyConf_presult__isset {
  _Nimbus_getTopologyConf_presult__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getTopologyConf_presult__isset;

class Nimbus_getTopologyConf_presult {
 public:

  static const char* ascii_fingerprint; // = "49854EEF51738863052F2475D0A9B6AD";
  static const uint8_t binary_fingerprint[16]; // = {0x49,0x85,0x4E,0xEF,0x51,0x73,0x88,0x63,0x05,0x2F,0x24,0x75,0xD0,0xA9,0xB6,0xAD};


  virtual ~Nimbus_getTopologyConf_presult() throw();
  std::string* success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getTopologyConf_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopologyConf_presult& obj);
};

typedef struct _Nimbus_getTopology_args__isset {
  _Nimbus_getTopology_args__isset() : id(false) {}
  bool id :1;
} _Nimbus_getTopology_args__isset;

class Nimbus_getTopology_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_getTopology_args(const Nimbus_getTopology_args&);
  Nimbus_getTopology_args& operator=(const Nimbus_getTopology_args&);
  Nimbus_getTopology_args() : id() {
  }

  virtual ~Nimbus_getTopology_args() throw();
  std::string id;

  _Nimbus_getTopology_args__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const Nimbus_getTopology_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopology_args& obj);
};


class Nimbus_getTopology_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_getTopology_pargs() throw();
  const std::string* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopology_pargs& obj);
};

typedef struct _Nimbus_getTopology_result__isset {
  _Nimbus_getTopology_result__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getTopology_result__isset;

class Nimbus_getTopology_result {
 public:

  static const char* ascii_fingerprint; // = "4C77CA726B1833406D5D06321DE62D5F";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x77,0xCA,0x72,0x6B,0x18,0x33,0x40,0x6D,0x5D,0x06,0x32,0x1D,0xE6,0x2D,0x5F};

  Nimbus_getTopology_result(const Nimbus_getTopology_result&);
  Nimbus_getTopology_result& operator=(const Nimbus_getTopology_result&);
  Nimbus_getTopology_result() {
  }

  virtual ~Nimbus_getTopology_result() throw();
  StormTopology success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getTopology_result__isset __isset;

  void __set_success(const StormTopology& val);

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_getTopology_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopology_result& obj);
};

typedef struct _Nimbus_getTopology_presult__isset {
  _Nimbus_getTopology_presult__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getTopology_presult__isset;

class Nimbus_getTopology_presult {
 public:

  static const char* ascii_fingerprint; // = "4C77CA726B1833406D5D06321DE62D5F";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x77,0xCA,0x72,0x6B,0x18,0x33,0x40,0x6D,0x5D,0x06,0x32,0x1D,0xE6,0x2D,0x5F};


  virtual ~Nimbus_getTopology_presult() throw();
  StormTopology* success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getTopology_presult& obj);
};

typedef struct _Nimbus_getUserTopology_args__isset {
  _Nimbus_getUserTopology_args__isset() : id(false) {}
  bool id :1;
} _Nimbus_getUserTopology_args__isset;

class Nimbus_getUserTopology_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Nimbus_getUserTopology_args(const Nimbus_getUserTopology_args&);
  Nimbus_getUserTopology_args& operator=(const Nimbus_getUserTopology_args&);
  Nimbus_getUserTopology_args() : id() {
  }

  virtual ~Nimbus_getUserTopology_args() throw();
  std::string id;

  _Nimbus_getUserTopology_args__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const Nimbus_getUserTopology_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getUserTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getUserTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getUserTopology_args& obj);
};


class Nimbus_getUserTopology_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Nimbus_getUserTopology_pargs() throw();
  const std::string* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getUserTopology_pargs& obj);
};

typedef struct _Nimbus_getUserTopology_result__isset {
  _Nimbus_getUserTopology_result__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getUserTopology_result__isset;

class Nimbus_getUserTopology_result {
 public:

  static const char* ascii_fingerprint; // = "4C77CA726B1833406D5D06321DE62D5F";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x77,0xCA,0x72,0x6B,0x18,0x33,0x40,0x6D,0x5D,0x06,0x32,0x1D,0xE6,0x2D,0x5F};

  Nimbus_getUserTopology_result(const Nimbus_getUserTopology_result&);
  Nimbus_getUserTopology_result& operator=(const Nimbus_getUserTopology_result&);
  Nimbus_getUserTopology_result() {
  }

  virtual ~Nimbus_getUserTopology_result() throw();
  StormTopology success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getUserTopology_result__isset __isset;

  void __set_success(const StormTopology& val);

  void __set_e(const NotAliveException& val);

  void __set_aze(const AuthorizationException& val);

  bool operator == (const Nimbus_getUserTopology_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    if (!(aze == rhs.aze))
      return false;
    return true;
  }
  bool operator != (const Nimbus_getUserTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nimbus_getUserTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getUserTopology_result& obj);
};

typedef struct _Nimbus_getUserTopology_presult__isset {
  _Nimbus_getUserTopology_presult__isset() : success(false), e(false), aze(false) {}
  bool success :1;
  bool e :1;
  bool aze :1;
} _Nimbus_getUserTopology_presult__isset;

class Nimbus_getUserTopology_presult {
 public:

  static const char* ascii_fingerprint; // = "4C77CA726B1833406D5D06321DE62D5F";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x77,0xCA,0x72,0x6B,0x18,0x33,0x40,0x6D,0x5D,0x06,0x32,0x1D,0xE6,0x2D,0x5F};


  virtual ~Nimbus_getUserTopology_presult() throw();
  StormTopology* success;
  NotAliveException e;
  AuthorizationException aze;

  _Nimbus_getUserTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Nimbus_getUserTopology_presult& obj);
};

class NimbusClient : virtual public NimbusIf {
 public:
  NimbusClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  NimbusClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void submitTopology(const std::string& name, const std::string& uploadedJarLocation, const std::string& jsonConf, const StormTopology& topology);
  void send_submitTopology(const std::string& name, const std::string& uploadedJarLocation, const std::string& jsonConf, const StormTopology& topology);
  void recv_submitTopology();
  void submitTopologyWithOpts(const std::string& name, const std::string& uploadedJarLocation, const std::string& jsonConf, const StormTopology& topology, const SubmitOptions& options);
  void send_submitTopologyWithOpts(const std::string& name, const std::string& uploadedJarLocation, const std::string& jsonConf, const StormTopology& topology, const SubmitOptions& options);
  void recv_submitTopologyWithOpts();
  void killTopology(const std::string& name);
  void send_killTopology(const std::string& name);
  void recv_killTopology();
  void killTopologyWithOpts(const std::string& name, const KillOptions& options);
  void send_killTopologyWithOpts(const std::string& name, const KillOptions& options);
  void recv_killTopologyWithOpts();
  void activate(const std::string& name);
  void send_activate(const std::string& name);
  void recv_activate();
  void deactivate(const std::string& name);
  void send_deactivate(const std::string& name);
  void recv_deactivate();
  void rebalance(const std::string& name, const RebalanceOptions& options);
  void send_rebalance(const std::string& name, const RebalanceOptions& options);
  void recv_rebalance();
  void uploadNewCredentials(const std::string& name, const Credentials& creds);
  void send_uploadNewCredentials(const std::string& name, const Credentials& creds);
  void recv_uploadNewCredentials();
  void beginFileUpload(std::string& _return);
  void send_beginFileUpload();
  void recv_beginFileUpload(std::string& _return);
  void uploadChunk(const std::string& location, const std::string& chunk);
  void send_uploadChunk(const std::string& location, const std::string& chunk);
  void recv_uploadChunk();
  void finishFileUpload(const std::string& location);
  void send_finishFileUpload(const std::string& location);
  void recv_finishFileUpload();
  void beginFileDownload(std::string& _return, const std::string& file);
  void send_beginFileDownload(const std::string& file);
  void recv_beginFileDownload(std::string& _return);
  void downloadChunk(std::string& _return, const std::string& id);
  void send_downloadChunk(const std::string& id);
  void recv_downloadChunk(std::string& _return);
  void getNimbusConf(std::string& _return);
  void send_getNimbusConf();
  void recv_getNimbusConf(std::string& _return);
  void getClusterInfo(ClusterSummary& _return);
  void send_getClusterInfo();
  void recv_getClusterInfo(ClusterSummary& _return);
  void getTopologyInfo(TopologyInfo& _return, const std::string& id);
  void send_getTopologyInfo(const std::string& id);
  void recv_getTopologyInfo(TopologyInfo& _return);
  void getTopologyInfoWithOpts(TopologyInfo& _return, const std::string& id, const GetInfoOptions& options);
  void send_getTopologyInfoWithOpts(const std::string& id, const GetInfoOptions& options);
  void recv_getTopologyInfoWithOpts(TopologyInfo& _return);
  void getTopologyConf(std::string& _return, const std::string& id);
  void send_getTopologyConf(const std::string& id);
  void recv_getTopologyConf(std::string& _return);
  void getTopology(StormTopology& _return, const std::string& id);
  void send_getTopology(const std::string& id);
  void recv_getTopology(StormTopology& _return);
  void getUserTopology(StormTopology& _return, const std::string& id);
  void send_getUserTopology(const std::string& id);
  void recv_getUserTopology(StormTopology& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class NimbusProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<NimbusIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (NimbusProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_submitTopology(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_submitTopologyWithOpts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_killTopology(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_killTopologyWithOpts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_activate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deactivate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rebalance(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_uploadNewCredentials(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_beginFileUpload(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_uploadChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_finishFileUpload(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_beginFileDownload(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_downloadChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNimbusConf(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getClusterInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTopologyInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTopologyInfoWithOpts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTopologyConf(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTopology(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getUserTopology(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  NimbusProcessor(boost::shared_ptr<NimbusIf> iface) :
    iface_(iface) {
    processMap_["submitTopology"] = &NimbusProcessor::process_submitTopology;
    processMap_["submitTopologyWithOpts"] = &NimbusProcessor::process_submitTopologyWithOpts;
    processMap_["killTopology"] = &NimbusProcessor::process_killTopology;
    processMap_["killTopologyWithOpts"] = &NimbusProcessor::process_killTopologyWithOpts;
    processMap_["activate"] = &NimbusProcessor::process_activate;
    processMap_["deactivate"] = &NimbusProcessor::process_deactivate;
    processMap_["rebalance"] = &NimbusProcessor::process_rebalance;
    processMap_["uploadNewCredentials"] = &NimbusProcessor::process_uploadNewCredentials;
    processMap_["beginFileUpload"] = &NimbusProcessor::process_beginFileUpload;
    processMap_["uploadChunk"] = &NimbusProcessor::process_uploadChunk;
    processMap_["finishFileUpload"] = &NimbusProcessor::process_finishFileUpload;
    processMap_["beginFileDownload"] = &NimbusProcessor::process_beginFileDownload;
    processMap_["downloadChunk"] = &NimbusProcessor::process_downloadChunk;
    processMap_["getNimbusConf"] = &NimbusProcessor::process_getNimbusConf;
    processMap_["getClusterInfo"] = &NimbusProcessor::process_getClusterInfo;
    processMap_["getTopologyInfo"] = &NimbusProcessor::process_getTopologyInfo;
    processMap_["getTopologyInfoWithOpts"] = &NimbusProcessor::process_getTopologyInfoWithOpts;
    processMap_["getTopologyConf"] = &NimbusProcessor::process_getTopologyConf;
    processMap_["getTopology"] = &NimbusProcessor::process_getTopology;
    processMap_["getUserTopology"] = &NimbusProcessor::process_getUserTopology;
  }

  virtual ~NimbusProcessor() {}
};

class NimbusProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  NimbusProcessorFactory(const ::boost::shared_ptr< NimbusIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< NimbusIfFactory > handlerFactory_;
};

class NimbusMultiface : virtual public NimbusIf {
 public:
  NimbusMultiface(std::vector<boost::shared_ptr<NimbusIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~NimbusMultiface() {}
 protected:
  std::vector<boost::shared_ptr<NimbusIf> > ifaces_;
  NimbusMultiface() {}
  void add(boost::shared_ptr<NimbusIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void submitTopology(const std::string& name, const std::string& uploadedJarLocation, const std::string& jsonConf, const StormTopology& topology) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->submitTopology(name, uploadedJarLocation, jsonConf, topology);
    }
    ifaces_[i]->submitTopology(name, uploadedJarLocation, jsonConf, topology);
  }

  void submitTopologyWithOpts(const std::string& name, const std::string& uploadedJarLocation, const std::string& jsonConf, const StormTopology& topology, const SubmitOptions& options) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->submitTopologyWithOpts(name, uploadedJarLocation, jsonConf, topology, options);
    }
    ifaces_[i]->submitTopologyWithOpts(name, uploadedJarLocation, jsonConf, topology, options);
  }

  void killTopology(const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->killTopology(name);
    }
    ifaces_[i]->killTopology(name);
  }

  void killTopologyWithOpts(const std::string& name, const KillOptions& options) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->killTopologyWithOpts(name, options);
    }
    ifaces_[i]->killTopologyWithOpts(name, options);
  }

  void activate(const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->activate(name);
    }
    ifaces_[i]->activate(name);
  }

  void deactivate(const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deactivate(name);
    }
    ifaces_[i]->deactivate(name);
  }

  void rebalance(const std::string& name, const RebalanceOptions& options) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rebalance(name, options);
    }
    ifaces_[i]->rebalance(name, options);
  }

  void uploadNewCredentials(const std::string& name, const Credentials& creds) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->uploadNewCredentials(name, creds);
    }
    ifaces_[i]->uploadNewCredentials(name, creds);
  }

  void beginFileUpload(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->beginFileUpload(_return);
    }
    ifaces_[i]->beginFileUpload(_return);
    return;
  }

  void uploadChunk(const std::string& location, const std::string& chunk) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->uploadChunk(location, chunk);
    }
    ifaces_[i]->uploadChunk(location, chunk);
  }

  void finishFileUpload(const std::string& location) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->finishFileUpload(location);
    }
    ifaces_[i]->finishFileUpload(location);
  }

  void beginFileDownload(std::string& _return, const std::string& file) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->beginFileDownload(_return, file);
    }
    ifaces_[i]->beginFileDownload(_return, file);
    return;
  }

  void downloadChunk(std::string& _return, const std::string& id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->downloadChunk(_return, id);
    }
    ifaces_[i]->downloadChunk(_return, id);
    return;
  }

  void getNimbusConf(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNimbusConf(_return);
    }
    ifaces_[i]->getNimbusConf(_return);
    return;
  }

  void getClusterInfo(ClusterSummary& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getClusterInfo(_return);
    }
    ifaces_[i]->getClusterInfo(_return);
    return;
  }

  void getTopologyInfo(TopologyInfo& _return, const std::string& id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTopologyInfo(_return, id);
    }
    ifaces_[i]->getTopologyInfo(_return, id);
    return;
  }

  void getTopologyInfoWithOpts(TopologyInfo& _return, const std::string& id, const GetInfoOptions& options) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTopologyInfoWithOpts(_return, id, options);
    }
    ifaces_[i]->getTopologyInfoWithOpts(_return, id, options);
    return;
  }

  void getTopologyConf(std::string& _return, const std::string& id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTopologyConf(_return, id);
    }
    ifaces_[i]->getTopologyConf(_return, id);
    return;
  }

  void getTopology(StormTopology& _return, const std::string& id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTopology(_return, id);
    }
    ifaces_[i]->getTopology(_return, id);
    return;
  }

  void getUserTopology(StormTopology& _return, const std::string& id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getUserTopology(_return, id);
    }
    ifaces_[i]->getUserTopology(_return, id);
    return;
  }

};



#endif
