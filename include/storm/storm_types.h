/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef storm_TYPES_H
#define storm_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct TopologyInitialStatus {
  enum type {
    ACTIVE = 1,
    INACTIVE = 2
  };
};

extern const std::map<int, const char*> _TopologyInitialStatus_VALUES_TO_NAMES;

struct TopologyStatus {
  enum type {
    ACTIVE = 1,
    INACTIVE = 2,
    REBALANCING = 3,
    KILLED = 4
  };
};

extern const std::map<int, const char*> _TopologyStatus_VALUES_TO_NAMES;

struct NumErrorsChoice {
  enum type {
    ALL = 0,
    NONE = 1,
    ONE = 2
  };
};

extern const std::map<int, const char*> _NumErrorsChoice_VALUES_TO_NAMES;

class JavaObjectArg;

class JavaObject;

class NullStruct;

class GlobalStreamId;

class Grouping;

class StreamInfo;

class ShellComponent;

class ComponentObject;

class ComponentCommon;

class SpoutSpec;

class Bolt;

class StateSpoutSpec;

class StormTopology;

class AlreadyAliveException;

class NotAliveException;

class AuthorizationException;

class InvalidTopologyException;

class TopologySummary;

class SupervisorSummary;

class NimbusSummary;

class ClusterSummary;

class ErrorInfo;

class BoltStats;

class SpoutStats;

class ExecutorSpecificStats;

class ExecutorStats;

class ExecutorInfo;

class ExecutorSummary;

class TopologyInfo;

class KillOptions;

class RebalanceOptions;

class Credentials;

class SubmitOptions;

class SupervisorInfo;

class NodeInfo;

class Assignment;

class TopologyActionOptions;

class StormBase;

class ClusterWorkerHeartbeat;

class ThriftSerializedObject;

class LocalStateData;

class LocalAssignment;

class LSSupervisorId;

class LSApprovedWorkers;

class LSSupervisorAssignments;

class LSWorkerHeartbeat;

class GetInfoOptions;

class DRPCRequest;

class DRPCExecutionException;

typedef struct _JavaObjectArg__isset {
  _JavaObjectArg__isset() : int_arg(false), long_arg(false), string_arg(false), bool_arg(false), binary_arg(false), double_arg(false) {}
  bool int_arg :1;
  bool long_arg :1;
  bool string_arg :1;
  bool bool_arg :1;
  bool binary_arg :1;
  bool double_arg :1;
} _JavaObjectArg__isset;

class JavaObjectArg {
 public:

  static const char* ascii_fingerprint; // = "C54D224D3B214A45D89C0D3A343D4AE1";
  static const uint8_t binary_fingerprint[16]; // = {0xC5,0x4D,0x22,0x4D,0x3B,0x21,0x4A,0x45,0xD8,0x9C,0x0D,0x3A,0x34,0x3D,0x4A,0xE1};

  JavaObjectArg(const JavaObjectArg&);
  JavaObjectArg& operator=(const JavaObjectArg&);
  JavaObjectArg() : int_arg(0), long_arg(0), string_arg(), bool_arg(0), binary_arg(), double_arg(0) {
  }

  virtual ~JavaObjectArg() throw();
  int32_t int_arg;
  int64_t long_arg;
  std::string string_arg;
  bool bool_arg;
  std::string binary_arg;
  double double_arg;

  _JavaObjectArg__isset __isset;

  void __set_int_arg(const int32_t val);

  void __set_long_arg(const int64_t val);

  void __set_string_arg(const std::string& val);

  void __set_bool_arg(const bool val);

  void __set_binary_arg(const std::string& val);

  void __set_double_arg(const double val);

  bool operator == (const JavaObjectArg & rhs) const
  {
    if (!(int_arg == rhs.int_arg))
      return false;
    if (!(long_arg == rhs.long_arg))
      return false;
    if (!(string_arg == rhs.string_arg))
      return false;
    if (!(bool_arg == rhs.bool_arg))
      return false;
    if (!(binary_arg == rhs.binary_arg))
      return false;
    if (!(double_arg == rhs.double_arg))
      return false;
    return true;
  }
  bool operator != (const JavaObjectArg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JavaObjectArg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const JavaObjectArg& obj);
};

void swap(JavaObjectArg &a, JavaObjectArg &b);


class JavaObject {
 public:

  static const char* ascii_fingerprint; // = "C64C4806126ACF15E6D851018D4B0A7F";
  static const uint8_t binary_fingerprint[16]; // = {0xC6,0x4C,0x48,0x06,0x12,0x6A,0xCF,0x15,0xE6,0xD8,0x51,0x01,0x8D,0x4B,0x0A,0x7F};

  JavaObject(const JavaObject&);
  JavaObject& operator=(const JavaObject&);
  JavaObject() : full_class_name() {
  }

  virtual ~JavaObject() throw();
  std::string full_class_name;
  std::vector<JavaObjectArg>  args_list;

  void __set_full_class_name(const std::string& val);

  void __set_args_list(const std::vector<JavaObjectArg> & val);

  bool operator == (const JavaObject & rhs) const
  {
    if (!(full_class_name == rhs.full_class_name))
      return false;
    if (!(args_list == rhs.args_list))
      return false;
    return true;
  }
  bool operator != (const JavaObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JavaObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const JavaObject& obj);
};

void swap(JavaObject &a, JavaObject &b);


class NullStruct {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  NullStruct(const NullStruct&);
  NullStruct& operator=(const NullStruct&);
  NullStruct() {
  }

  virtual ~NullStruct() throw();

  bool operator == (const NullStruct & /* rhs */) const
  {
    return true;
  }
  bool operator != (const NullStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NullStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const NullStruct& obj);
};

void swap(NullStruct &a, NullStruct &b);


class GlobalStreamId {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  GlobalStreamId(const GlobalStreamId&);
  GlobalStreamId& operator=(const GlobalStreamId&);
  GlobalStreamId() : componentId(), streamId() {
  }

  virtual ~GlobalStreamId() throw();
  std::string componentId;
  std::string streamId;

  void __set_componentId(const std::string& val);

  void __set_streamId(const std::string& val);

  bool operator == (const GlobalStreamId & rhs) const
  {
    if (!(componentId == rhs.componentId))
      return false;
    if (!(streamId == rhs.streamId))
      return false;
    return true;
  }
  bool operator != (const GlobalStreamId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GlobalStreamId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const GlobalStreamId& obj);
};

void swap(GlobalStreamId &a, GlobalStreamId &b);

typedef struct _Grouping__isset {
  _Grouping__isset() : fields(false), shuffle(false), all(false), none(false), direct(false), custom_object(false), custom_serialized(false), local_or_shuffle(false) {}
  bool fields :1;
  bool shuffle :1;
  bool all :1;
  bool none :1;
  bool direct :1;
  bool custom_object :1;
  bool custom_serialized :1;
  bool local_or_shuffle :1;
} _Grouping__isset;

class Grouping {
 public:

  static const char* ascii_fingerprint; // = "E89DD90D7BE68BED78E547CC12CC26C2";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x9D,0xD9,0x0D,0x7B,0xE6,0x8B,0xED,0x78,0xE5,0x47,0xCC,0x12,0xCC,0x26,0xC2};

  Grouping(const Grouping&);
  Grouping& operator=(const Grouping&);
  Grouping() : custom_serialized() {
  }

  virtual ~Grouping() throw();
  std::vector<std::string>  fields;
  NullStruct shuffle;
  NullStruct all;
  NullStruct none;
  NullStruct direct;
  JavaObject custom_object;
  std::string custom_serialized;
  NullStruct local_or_shuffle;

  _Grouping__isset __isset;

  void __set_fields(const std::vector<std::string> & val);

  void __set_shuffle(const NullStruct& val);

  void __set_all(const NullStruct& val);

  void __set_none(const NullStruct& val);

  void __set_direct(const NullStruct& val);

  void __set_custom_object(const JavaObject& val);

  void __set_custom_serialized(const std::string& val);

  void __set_local_or_shuffle(const NullStruct& val);

  bool operator == (const Grouping & rhs) const
  {
    if (!(fields == rhs.fields))
      return false;
    if (!(shuffle == rhs.shuffle))
      return false;
    if (!(all == rhs.all))
      return false;
    if (!(none == rhs.none))
      return false;
    if (!(direct == rhs.direct))
      return false;
    if (!(custom_object == rhs.custom_object))
      return false;
    if (!(custom_serialized == rhs.custom_serialized))
      return false;
    if (!(local_or_shuffle == rhs.local_or_shuffle))
      return false;
    return true;
  }
  bool operator != (const Grouping &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Grouping & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Grouping& obj);
};

void swap(Grouping &a, Grouping &b);


class StreamInfo {
 public:

  static const char* ascii_fingerprint; // = "91B6D52A7BB8CAC890FB4C69B1CF4C4E";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0xB6,0xD5,0x2A,0x7B,0xB8,0xCA,0xC8,0x90,0xFB,0x4C,0x69,0xB1,0xCF,0x4C,0x4E};

  StreamInfo(const StreamInfo&);
  StreamInfo& operator=(const StreamInfo&);
  StreamInfo() : direct(0) {
  }

  virtual ~StreamInfo() throw();
  std::vector<std::string>  output_fields;
  bool direct;

  void __set_output_fields(const std::vector<std::string> & val);

  void __set_direct(const bool val);

  bool operator == (const StreamInfo & rhs) const
  {
    if (!(output_fields == rhs.output_fields))
      return false;
    if (!(direct == rhs.direct))
      return false;
    return true;
  }
  bool operator != (const StreamInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StreamInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const StreamInfo& obj);
};

void swap(StreamInfo &a, StreamInfo &b);

typedef struct _ShellComponent__isset {
  _ShellComponent__isset() : execution_command(false), script(false) {}
  bool execution_command :1;
  bool script :1;
} _ShellComponent__isset;

class ShellComponent {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  ShellComponent(const ShellComponent&);
  ShellComponent& operator=(const ShellComponent&);
  ShellComponent() : execution_command(), script() {
  }

  virtual ~ShellComponent() throw();
  std::string execution_command;
  std::string script;

  _ShellComponent__isset __isset;

  void __set_execution_command(const std::string& val);

  void __set_script(const std::string& val);

  bool operator == (const ShellComponent & rhs) const
  {
    if (!(execution_command == rhs.execution_command))
      return false;
    if (!(script == rhs.script))
      return false;
    return true;
  }
  bool operator != (const ShellComponent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShellComponent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ShellComponent& obj);
};

void swap(ShellComponent &a, ShellComponent &b);

typedef struct _ComponentObject__isset {
  _ComponentObject__isset() : serialized_java(false), shell(false), java_object(false) {}
  bool serialized_java :1;
  bool shell :1;
  bool java_object :1;
} _ComponentObject__isset;

class ComponentObject {
 public:

  static const char* ascii_fingerprint; // = "076645EC014A2B36FFF319EBC93E045E";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0x66,0x45,0xEC,0x01,0x4A,0x2B,0x36,0xFF,0xF3,0x19,0xEB,0xC9,0x3E,0x04,0x5E};

  ComponentObject(const ComponentObject&);
  ComponentObject& operator=(const ComponentObject&);
  ComponentObject() : serialized_java() {
  }

  virtual ~ComponentObject() throw();
  std::string serialized_java;
  ShellComponent shell;
  JavaObject java_object;

  _ComponentObject__isset __isset;

  void __set_serialized_java(const std::string& val);

  void __set_shell(const ShellComponent& val);

  void __set_java_object(const JavaObject& val);

  bool operator == (const ComponentObject & rhs) const
  {
    if (!(serialized_java == rhs.serialized_java))
      return false;
    if (!(shell == rhs.shell))
      return false;
    if (!(java_object == rhs.java_object))
      return false;
    return true;
  }
  bool operator != (const ComponentObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ComponentObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ComponentObject& obj);
};

void swap(ComponentObject &a, ComponentObject &b);

typedef struct _ComponentCommon__isset {
  _ComponentCommon__isset() : parallelism_hint(false), json_conf(false) {}
  bool parallelism_hint :1;
  bool json_conf :1;
} _ComponentCommon__isset;

class ComponentCommon {
 public:

  static const char* ascii_fingerprint; // = "7A80513E6D2ABEAA869116E188533920";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0x80,0x51,0x3E,0x6D,0x2A,0xBE,0xAA,0x86,0x91,0x16,0xE1,0x88,0x53,0x39,0x20};

  ComponentCommon(const ComponentCommon&);
  ComponentCommon& operator=(const ComponentCommon&);
  ComponentCommon() : parallelism_hint(0), json_conf() {
  }

  virtual ~ComponentCommon() throw();
  std::map<GlobalStreamId, Grouping>  inputs;
  std::map<std::string, StreamInfo>  streams;
  int32_t parallelism_hint;
  std::string json_conf;

  _ComponentCommon__isset __isset;

  void __set_inputs(const std::map<GlobalStreamId, Grouping> & val);

  void __set_streams(const std::map<std::string, StreamInfo> & val);

  void __set_parallelism_hint(const int32_t val);

  void __set_json_conf(const std::string& val);

  bool operator == (const ComponentCommon & rhs) const
  {
    if (!(inputs == rhs.inputs))
      return false;
    if (!(streams == rhs.streams))
      return false;
    if (__isset.parallelism_hint != rhs.__isset.parallelism_hint)
      return false;
    else if (__isset.parallelism_hint && !(parallelism_hint == rhs.parallelism_hint))
      return false;
    if (__isset.json_conf != rhs.__isset.json_conf)
      return false;
    else if (__isset.json_conf && !(json_conf == rhs.json_conf))
      return false;
    return true;
  }
  bool operator != (const ComponentCommon &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ComponentCommon & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ComponentCommon& obj);
};

void swap(ComponentCommon &a, ComponentCommon &b);


class SpoutSpec {
 public:

  static const char* ascii_fingerprint; // = "C147E300907CC931D835C33B9EC6140A";
  static const uint8_t binary_fingerprint[16]; // = {0xC1,0x47,0xE3,0x00,0x90,0x7C,0xC9,0x31,0xD8,0x35,0xC3,0x3B,0x9E,0xC6,0x14,0x0A};

  SpoutSpec(const SpoutSpec&);
  SpoutSpec& operator=(const SpoutSpec&);
  SpoutSpec() {
  }

  virtual ~SpoutSpec() throw();
  ComponentObject spout_object;
  ComponentCommon common;

  void __set_spout_object(const ComponentObject& val);

  void __set_common(const ComponentCommon& val);

  bool operator == (const SpoutSpec & rhs) const
  {
    if (!(spout_object == rhs.spout_object))
      return false;
    if (!(common == rhs.common))
      return false;
    return true;
  }
  bool operator != (const SpoutSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpoutSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SpoutSpec& obj);
};

void swap(SpoutSpec &a, SpoutSpec &b);


class Bolt {
 public:

  static const char* ascii_fingerprint; // = "C147E300907CC931D835C33B9EC6140A";
  static const uint8_t binary_fingerprint[16]; // = {0xC1,0x47,0xE3,0x00,0x90,0x7C,0xC9,0x31,0xD8,0x35,0xC3,0x3B,0x9E,0xC6,0x14,0x0A};

  Bolt(const Bolt&);
  Bolt& operator=(const Bolt&);
  Bolt() {
  }

  virtual ~Bolt() throw();
  ComponentObject bolt_object;
  ComponentCommon common;

  void __set_bolt_object(const ComponentObject& val);

  void __set_common(const ComponentCommon& val);

  bool operator == (const Bolt & rhs) const
  {
    if (!(bolt_object == rhs.bolt_object))
      return false;
    if (!(common == rhs.common))
      return false;
    return true;
  }
  bool operator != (const Bolt &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bolt & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Bolt& obj);
};

void swap(Bolt &a, Bolt &b);


class StateSpoutSpec {
 public:

  static const char* ascii_fingerprint; // = "C147E300907CC931D835C33B9EC6140A";
  static const uint8_t binary_fingerprint[16]; // = {0xC1,0x47,0xE3,0x00,0x90,0x7C,0xC9,0x31,0xD8,0x35,0xC3,0x3B,0x9E,0xC6,0x14,0x0A};

  StateSpoutSpec(const StateSpoutSpec&);
  StateSpoutSpec& operator=(const StateSpoutSpec&);
  StateSpoutSpec() {
  }

  virtual ~StateSpoutSpec() throw();
  ComponentObject state_spout_object;
  ComponentCommon common;

  void __set_state_spout_object(const ComponentObject& val);

  void __set_common(const ComponentCommon& val);

  bool operator == (const StateSpoutSpec & rhs) const
  {
    if (!(state_spout_object == rhs.state_spout_object))
      return false;
    if (!(common == rhs.common))
      return false;
    return true;
  }
  bool operator != (const StateSpoutSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StateSpoutSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const StateSpoutSpec& obj);
};

void swap(StateSpoutSpec &a, StateSpoutSpec &b);


class StormTopology {
 public:

  static const char* ascii_fingerprint; // = "F265E9D70C07815346C4D9723004FD82";
  static const uint8_t binary_fingerprint[16]; // = {0xF2,0x65,0xE9,0xD7,0x0C,0x07,0x81,0x53,0x46,0xC4,0xD9,0x72,0x30,0x04,0xFD,0x82};

  StormTopology(const StormTopology&);
  StormTopology& operator=(const StormTopology&);
  StormTopology() {
  }

  virtual ~StormTopology() throw();
  std::map<std::string, SpoutSpec>  spouts;
  std::map<std::string, Bolt>  bolts;
  std::map<std::string, StateSpoutSpec>  state_spouts;

  void __set_spouts(const std::map<std::string, SpoutSpec> & val);

  void __set_bolts(const std::map<std::string, Bolt> & val);

  void __set_state_spouts(const std::map<std::string, StateSpoutSpec> & val);

  bool operator == (const StormTopology & rhs) const
  {
    if (!(spouts == rhs.spouts))
      return false;
    if (!(bolts == rhs.bolts))
      return false;
    if (!(state_spouts == rhs.state_spouts))
      return false;
    return true;
  }
  bool operator != (const StormTopology &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StormTopology & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const StormTopology& obj);
};

void swap(StormTopology &a, StormTopology &b);


class AlreadyAliveException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  AlreadyAliveException(const AlreadyAliveException&);
  AlreadyAliveException& operator=(const AlreadyAliveException&);
  AlreadyAliveException() : msg() {
  }

  virtual ~AlreadyAliveException() throw();
  std::string msg;

  void __set_msg(const std::string& val);

  bool operator == (const AlreadyAliveException & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const AlreadyAliveException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlreadyAliveException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const AlreadyAliveException& obj);
};

void swap(AlreadyAliveException &a, AlreadyAliveException &b);


class NotAliveException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  NotAliveException(const NotAliveException&);
  NotAliveException& operator=(const NotAliveException&);
  NotAliveException() : msg() {
  }

  virtual ~NotAliveException() throw();
  std::string msg;

  void __set_msg(const std::string& val);

  bool operator == (const NotAliveException & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const NotAliveException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotAliveException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const NotAliveException& obj);
};

void swap(NotAliveException &a, NotAliveException &b);


class AuthorizationException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  AuthorizationException(const AuthorizationException&);
  AuthorizationException& operator=(const AuthorizationException&);
  AuthorizationException() : msg() {
  }

  virtual ~AuthorizationException() throw();
  std::string msg;

  void __set_msg(const std::string& val);

  bool operator == (const AuthorizationException & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const AuthorizationException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuthorizationException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const AuthorizationException& obj);
};

void swap(AuthorizationException &a, AuthorizationException &b);


class InvalidTopologyException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  InvalidTopologyException(const InvalidTopologyException&);
  InvalidTopologyException& operator=(const InvalidTopologyException&);
  InvalidTopologyException() : msg() {
  }

  virtual ~InvalidTopologyException() throw();
  std::string msg;

  void __set_msg(const std::string& val);

  bool operator == (const InvalidTopologyException & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const InvalidTopologyException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidTopologyException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const InvalidTopologyException& obj);
};

void swap(InvalidTopologyException &a, InvalidTopologyException &b);

typedef struct _TopologySummary__isset {
  _TopologySummary__isset() : sched_status(false), owner(false), replication_count(false) {}
  bool sched_status :1;
  bool owner :1;
  bool replication_count :1;
} _TopologySummary__isset;

class TopologySummary {
 public:

  static const char* ascii_fingerprint; // = "EE53A8353B1011ADD09D8F169CE9F2F0";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0x53,0xA8,0x35,0x3B,0x10,0x11,0xAD,0xD0,0x9D,0x8F,0x16,0x9C,0xE9,0xF2,0xF0};

  TopologySummary(const TopologySummary&);
  TopologySummary& operator=(const TopologySummary&);
  TopologySummary() : id(), name(), num_tasks(0), num_executors(0), num_workers(0), uptime_secs(0), status(), sched_status(), owner(), replication_count(0) {
  }

  virtual ~TopologySummary() throw();
  std::string id;
  std::string name;
  int32_t num_tasks;
  int32_t num_executors;
  int32_t num_workers;
  int32_t uptime_secs;
  std::string status;
  std::string sched_status;
  std::string owner;
  int32_t replication_count;

  _TopologySummary__isset __isset;

  void __set_id(const std::string& val);

  void __set_name(const std::string& val);

  void __set_num_tasks(const int32_t val);

  void __set_num_executors(const int32_t val);

  void __set_num_workers(const int32_t val);

  void __set_uptime_secs(const int32_t val);

  void __set_status(const std::string& val);

  void __set_sched_status(const std::string& val);

  void __set_owner(const std::string& val);

  void __set_replication_count(const int32_t val);

  bool operator == (const TopologySummary & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(num_tasks == rhs.num_tasks))
      return false;
    if (!(num_executors == rhs.num_executors))
      return false;
    if (!(num_workers == rhs.num_workers))
      return false;
    if (!(uptime_secs == rhs.uptime_secs))
      return false;
    if (!(status == rhs.status))
      return false;
    if (__isset.sched_status != rhs.__isset.sched_status)
      return false;
    else if (__isset.sched_status && !(sched_status == rhs.sched_status))
      return false;
    if (__isset.owner != rhs.__isset.owner)
      return false;
    else if (__isset.owner && !(owner == rhs.owner))
      return false;
    if (__isset.replication_count != rhs.__isset.replication_count)
      return false;
    else if (__isset.replication_count && !(replication_count == rhs.replication_count))
      return false;
    return true;
  }
  bool operator != (const TopologySummary &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TopologySummary & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TopologySummary& obj);
};

void swap(TopologySummary &a, TopologySummary &b);

typedef struct _SupervisorSummary__isset {
  _SupervisorSummary__isset() : version(true) {}
  bool version :1;
} _SupervisorSummary__isset;

class SupervisorSummary {
 public:

  static const char* ascii_fingerprint; // = "D4C0ABA77AFAF9E91599691EEBEE037C";
  static const uint8_t binary_fingerprint[16]; // = {0xD4,0xC0,0xAB,0xA7,0x7A,0xFA,0xF9,0xE9,0x15,0x99,0x69,0x1E,0xEB,0xEE,0x03,0x7C};

  SupervisorSummary(const SupervisorSummary&);
  SupervisorSummary& operator=(const SupervisorSummary&);
  SupervisorSummary() : host(), uptime_secs(0), num_workers(0), num_used_workers(0), supervisor_id(), version("VERSION_NOT_PROVIDED") {
  }

  virtual ~SupervisorSummary() throw();
  std::string host;
  int32_t uptime_secs;
  int32_t num_workers;
  int32_t num_used_workers;
  std::string supervisor_id;
  std::string version;

  _SupervisorSummary__isset __isset;

  void __set_host(const std::string& val);

  void __set_uptime_secs(const int32_t val);

  void __set_num_workers(const int32_t val);

  void __set_num_used_workers(const int32_t val);

  void __set_supervisor_id(const std::string& val);

  void __set_version(const std::string& val);

  bool operator == (const SupervisorSummary & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(uptime_secs == rhs.uptime_secs))
      return false;
    if (!(num_workers == rhs.num_workers))
      return false;
    if (!(num_used_workers == rhs.num_used_workers))
      return false;
    if (!(supervisor_id == rhs.supervisor_id))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const SupervisorSummary &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SupervisorSummary & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SupervisorSummary& obj);
};

void swap(SupervisorSummary &a, SupervisorSummary &b);


class NimbusSummary {
 public:

  static const char* ascii_fingerprint; // = "12C210147C9A6E50C23D5398117EEB26";
  static const uint8_t binary_fingerprint[16]; // = {0x12,0xC2,0x10,0x14,0x7C,0x9A,0x6E,0x50,0xC2,0x3D,0x53,0x98,0x11,0x7E,0xEB,0x26};

  NimbusSummary(const NimbusSummary&);
  NimbusSummary& operator=(const NimbusSummary&);
  NimbusSummary() : host(), port(0), uptime_secs(0), isLeader(0), version() {
  }

  virtual ~NimbusSummary() throw();
  std::string host;
  int32_t port;
  int32_t uptime_secs;
  bool isLeader;
  std::string version;

  void __set_host(const std::string& val);

  void __set_port(const int32_t val);

  void __set_uptime_secs(const int32_t val);

  void __set_isLeader(const bool val);

  void __set_version(const std::string& val);

  bool operator == (const NimbusSummary & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(uptime_secs == rhs.uptime_secs))
      return false;
    if (!(isLeader == rhs.isLeader))
      return false;
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const NimbusSummary &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NimbusSummary & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const NimbusSummary& obj);
};

void swap(NimbusSummary &a, NimbusSummary &b);


class ClusterSummary {
 public:

  static const char* ascii_fingerprint; // = "4520C143DEA4C3A94A5E370E22352785";
  static const uint8_t binary_fingerprint[16]; // = {0x45,0x20,0xC1,0x43,0xDE,0xA4,0xC3,0xA9,0x4A,0x5E,0x37,0x0E,0x22,0x35,0x27,0x85};

  ClusterSummary(const ClusterSummary&);
  ClusterSummary& operator=(const ClusterSummary&);
  ClusterSummary() {
  }

  virtual ~ClusterSummary() throw();
  std::vector<SupervisorSummary>  supervisors;
  std::vector<TopologySummary>  topologies;
  std::vector<NimbusSummary>  nimbuses;

  void __set_supervisors(const std::vector<SupervisorSummary> & val);

  void __set_topologies(const std::vector<TopologySummary> & val);

  void __set_nimbuses(const std::vector<NimbusSummary> & val);

  bool operator == (const ClusterSummary & rhs) const
  {
    if (!(supervisors == rhs.supervisors))
      return false;
    if (!(topologies == rhs.topologies))
      return false;
    if (!(nimbuses == rhs.nimbuses))
      return false;
    return true;
  }
  bool operator != (const ClusterSummary &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterSummary & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ClusterSummary& obj);
};

void swap(ClusterSummary &a, ClusterSummary &b);

typedef struct _ErrorInfo__isset {
  _ErrorInfo__isset() : host(false), port(false) {}
  bool host :1;
  bool port :1;
} _ErrorInfo__isset;

class ErrorInfo {
 public:

  static const char* ascii_fingerprint; // = "4FB05A4E7A2B363E9C2CC250B78F2EDF";
  static const uint8_t binary_fingerprint[16]; // = {0x4F,0xB0,0x5A,0x4E,0x7A,0x2B,0x36,0x3E,0x9C,0x2C,0xC2,0x50,0xB7,0x8F,0x2E,0xDF};

  ErrorInfo(const ErrorInfo&);
  ErrorInfo& operator=(const ErrorInfo&);
  ErrorInfo() : error(), error_time_secs(0), host(), port(0) {
  }

  virtual ~ErrorInfo() throw();
  std::string error;
  int32_t error_time_secs;
  std::string host;
  int32_t port;

  _ErrorInfo__isset __isset;

  void __set_error(const std::string& val);

  void __set_error_time_secs(const int32_t val);

  void __set_host(const std::string& val);

  void __set_port(const int32_t val);

  bool operator == (const ErrorInfo & rhs) const
  {
    if (!(error == rhs.error))
      return false;
    if (!(error_time_secs == rhs.error_time_secs))
      return false;
    if (__isset.host != rhs.__isset.host)
      return false;
    else if (__isset.host && !(host == rhs.host))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const ErrorInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ErrorInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ErrorInfo& obj);
};

void swap(ErrorInfo &a, ErrorInfo &b);


class BoltStats {
 public:

  static const char* ascii_fingerprint; // = "7DEB96D4FC73B7907F1020E988ECC576";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0xEB,0x96,0xD4,0xFC,0x73,0xB7,0x90,0x7F,0x10,0x20,0xE9,0x88,0xEC,0xC5,0x76};

  BoltStats(const BoltStats&);
  BoltStats& operator=(const BoltStats&);
  BoltStats() {
  }

  virtual ~BoltStats() throw();
  std::map<std::string, std::map<GlobalStreamId, int64_t> >  acked;
  std::map<std::string, std::map<GlobalStreamId, int64_t> >  failed;
  std::map<std::string, std::map<GlobalStreamId, double> >  process_ms_avg;
  std::map<std::string, std::map<GlobalStreamId, int64_t> >  executed;
  std::map<std::string, std::map<GlobalStreamId, double> >  execute_ms_avg;

  void __set_acked(const std::map<std::string, std::map<GlobalStreamId, int64_t> > & val);

  void __set_failed(const std::map<std::string, std::map<GlobalStreamId, int64_t> > & val);

  void __set_process_ms_avg(const std::map<std::string, std::map<GlobalStreamId, double> > & val);

  void __set_executed(const std::map<std::string, std::map<GlobalStreamId, int64_t> > & val);

  void __set_execute_ms_avg(const std::map<std::string, std::map<GlobalStreamId, double> > & val);

  bool operator == (const BoltStats & rhs) const
  {
    if (!(acked == rhs.acked))
      return false;
    if (!(failed == rhs.failed))
      return false;
    if (!(process_ms_avg == rhs.process_ms_avg))
      return false;
    if (!(executed == rhs.executed))
      return false;
    if (!(execute_ms_avg == rhs.execute_ms_avg))
      return false;
    return true;
  }
  bool operator != (const BoltStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BoltStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const BoltStats& obj);
};

void swap(BoltStats &a, BoltStats &b);


class SpoutStats {
 public:

  static const char* ascii_fingerprint; // = "A607D21256A69EE000B9DD79CCF8043B";
  static const uint8_t binary_fingerprint[16]; // = {0xA6,0x07,0xD2,0x12,0x56,0xA6,0x9E,0xE0,0x00,0xB9,0xDD,0x79,0xCC,0xF8,0x04,0x3B};

  SpoutStats(const SpoutStats&);
  SpoutStats& operator=(const SpoutStats&);
  SpoutStats() {
  }

  virtual ~SpoutStats() throw();
  std::map<std::string, std::map<std::string, int64_t> >  acked;
  std::map<std::string, std::map<std::string, int64_t> >  failed;
  std::map<std::string, std::map<std::string, double> >  complete_ms_avg;

  void __set_acked(const std::map<std::string, std::map<std::string, int64_t> > & val);

  void __set_failed(const std::map<std::string, std::map<std::string, int64_t> > & val);

  void __set_complete_ms_avg(const std::map<std::string, std::map<std::string, double> > & val);

  bool operator == (const SpoutStats & rhs) const
  {
    if (!(acked == rhs.acked))
      return false;
    if (!(failed == rhs.failed))
      return false;
    if (!(complete_ms_avg == rhs.complete_ms_avg))
      return false;
    return true;
  }
  bool operator != (const SpoutStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpoutStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SpoutStats& obj);
};

void swap(SpoutStats &a, SpoutStats &b);

typedef struct _ExecutorSpecificStats__isset {
  _ExecutorSpecificStats__isset() : bolt(false), spout(false) {}
  bool bolt :1;
  bool spout :1;
} _ExecutorSpecificStats__isset;

class ExecutorSpecificStats {
 public:

  static const char* ascii_fingerprint; // = "B58C5B4D6D66AB5130E3BCB74686D6FB";
  static const uint8_t binary_fingerprint[16]; // = {0xB5,0x8C,0x5B,0x4D,0x6D,0x66,0xAB,0x51,0x30,0xE3,0xBC,0xB7,0x46,0x86,0xD6,0xFB};

  ExecutorSpecificStats(const ExecutorSpecificStats&);
  ExecutorSpecificStats& operator=(const ExecutorSpecificStats&);
  ExecutorSpecificStats() {
  }

  virtual ~ExecutorSpecificStats() throw();
  BoltStats bolt;
  SpoutStats spout;

  _ExecutorSpecificStats__isset __isset;

  void __set_bolt(const BoltStats& val);

  void __set_spout(const SpoutStats& val);

  bool operator == (const ExecutorSpecificStats & rhs) const
  {
    if (!(bolt == rhs.bolt))
      return false;
    if (!(spout == rhs.spout))
      return false;
    return true;
  }
  bool operator != (const ExecutorSpecificStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExecutorSpecificStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ExecutorSpecificStats& obj);
};

void swap(ExecutorSpecificStats &a, ExecutorSpecificStats &b);


class ExecutorStats {
 public:

  static const char* ascii_fingerprint; // = "4CE1362C03F82DD414875AB6318787B3";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0xE1,0x36,0x2C,0x03,0xF8,0x2D,0xD4,0x14,0x87,0x5A,0xB6,0x31,0x87,0x87,0xB3};

  ExecutorStats(const ExecutorStats&);
  ExecutorStats& operator=(const ExecutorStats&);
  ExecutorStats() : rate(0) {
  }

  virtual ~ExecutorStats() throw();
  std::map<std::string, std::map<std::string, int64_t> >  emitted;
  std::map<std::string, std::map<std::string, int64_t> >  transferred;
  ExecutorSpecificStats specific;
  double rate;

  void __set_emitted(const std::map<std::string, std::map<std::string, int64_t> > & val);

  void __set_transferred(const std::map<std::string, std::map<std::string, int64_t> > & val);

  void __set_specific(const ExecutorSpecificStats& val);

  void __set_rate(const double val);

  bool operator == (const ExecutorStats & rhs) const
  {
    if (!(emitted == rhs.emitted))
      return false;
    if (!(transferred == rhs.transferred))
      return false;
    if (!(specific == rhs.specific))
      return false;
    if (!(rate == rhs.rate))
      return false;
    return true;
  }
  bool operator != (const ExecutorStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExecutorStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ExecutorStats& obj);
};

void swap(ExecutorStats &a, ExecutorStats &b);


class ExecutorInfo {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  ExecutorInfo(const ExecutorInfo&);
  ExecutorInfo& operator=(const ExecutorInfo&);
  ExecutorInfo() : task_start(0), task_end(0) {
  }

  virtual ~ExecutorInfo() throw();
  int32_t task_start;
  int32_t task_end;

  void __set_task_start(const int32_t val);

  void __set_task_end(const int32_t val);

  bool operator == (const ExecutorInfo & rhs) const
  {
    if (!(task_start == rhs.task_start))
      return false;
    if (!(task_end == rhs.task_end))
      return false;
    return true;
  }
  bool operator != (const ExecutorInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExecutorInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ExecutorInfo& obj);
};

void swap(ExecutorInfo &a, ExecutorInfo &b);

typedef struct _ExecutorSummary__isset {
  _ExecutorSummary__isset() : stats(false) {}
  bool stats :1;
} _ExecutorSummary__isset;

class ExecutorSummary {
 public:

  static const char* ascii_fingerprint; // = "CA4F05E1B8BE8777885F9100754D671C";
  static const uint8_t binary_fingerprint[16]; // = {0xCA,0x4F,0x05,0xE1,0xB8,0xBE,0x87,0x77,0x88,0x5F,0x91,0x00,0x75,0x4D,0x67,0x1C};

  ExecutorSummary(const ExecutorSummary&);
  ExecutorSummary& operator=(const ExecutorSummary&);
  ExecutorSummary() : component_id(), host(), port(0), uptime_secs(0) {
  }

  virtual ~ExecutorSummary() throw();
  ExecutorInfo executor_info;
  std::string component_id;
  std::string host;
  int32_t port;
  int32_t uptime_secs;
  ExecutorStats stats;

  _ExecutorSummary__isset __isset;

  void __set_executor_info(const ExecutorInfo& val);

  void __set_component_id(const std::string& val);

  void __set_host(const std::string& val);

  void __set_port(const int32_t val);

  void __set_uptime_secs(const int32_t val);

  void __set_stats(const ExecutorStats& val);

  bool operator == (const ExecutorSummary & rhs) const
  {
    if (!(executor_info == rhs.executor_info))
      return false;
    if (!(component_id == rhs.component_id))
      return false;
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(uptime_secs == rhs.uptime_secs))
      return false;
    if (__isset.stats != rhs.__isset.stats)
      return false;
    else if (__isset.stats && !(stats == rhs.stats))
      return false;
    return true;
  }
  bool operator != (const ExecutorSummary &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExecutorSummary & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ExecutorSummary& obj);
};

void swap(ExecutorSummary &a, ExecutorSummary &b);

typedef struct _TopologyInfo__isset {
  _TopologyInfo__isset() : sched_status(false), owner(false), replication_count(false) {}
  bool sched_status :1;
  bool owner :1;
  bool replication_count :1;
} _TopologyInfo__isset;

class TopologyInfo {
 public:

  static const char* ascii_fingerprint; // = "689310F11F11872DC81B04FD22BEA177";
  static const uint8_t binary_fingerprint[16]; // = {0x68,0x93,0x10,0xF1,0x1F,0x11,0x87,0x2D,0xC8,0x1B,0x04,0xFD,0x22,0xBE,0xA1,0x77};

  TopologyInfo(const TopologyInfo&);
  TopologyInfo& operator=(const TopologyInfo&);
  TopologyInfo() : id(), name(), uptime_secs(0), status(), sched_status(), owner(), replication_count(0) {
  }

  virtual ~TopologyInfo() throw();
  std::string id;
  std::string name;
  int32_t uptime_secs;
  std::vector<ExecutorSummary>  executors;
  std::string status;
  std::map<std::string, std::vector<ErrorInfo> >  errors;
  std::string sched_status;
  std::string owner;
  int32_t replication_count;

  _TopologyInfo__isset __isset;

  void __set_id(const std::string& val);

  void __set_name(const std::string& val);

  void __set_uptime_secs(const int32_t val);

  void __set_executors(const std::vector<ExecutorSummary> & val);

  void __set_status(const std::string& val);

  void __set_errors(const std::map<std::string, std::vector<ErrorInfo> > & val);

  void __set_sched_status(const std::string& val);

  void __set_owner(const std::string& val);

  void __set_replication_count(const int32_t val);

  bool operator == (const TopologyInfo & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(uptime_secs == rhs.uptime_secs))
      return false;
    if (!(executors == rhs.executors))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(errors == rhs.errors))
      return false;
    if (__isset.sched_status != rhs.__isset.sched_status)
      return false;
    else if (__isset.sched_status && !(sched_status == rhs.sched_status))
      return false;
    if (__isset.owner != rhs.__isset.owner)
      return false;
    else if (__isset.owner && !(owner == rhs.owner))
      return false;
    if (__isset.replication_count != rhs.__isset.replication_count)
      return false;
    else if (__isset.replication_count && !(replication_count == rhs.replication_count))
      return false;
    return true;
  }
  bool operator != (const TopologyInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TopologyInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TopologyInfo& obj);
};

void swap(TopologyInfo &a, TopologyInfo &b);

typedef struct _KillOptions__isset {
  _KillOptions__isset() : wait_secs(false) {}
  bool wait_secs :1;
} _KillOptions__isset;

class KillOptions {
 public:

  static const char* ascii_fingerprint; // = "E7A96B151330359E84C0A3AC91BCBACD";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0xA9,0x6B,0x15,0x13,0x30,0x35,0x9E,0x84,0xC0,0xA3,0xAC,0x91,0xBC,0xBA,0xCD};

  KillOptions(const KillOptions&);
  KillOptions& operator=(const KillOptions&);
  KillOptions() : wait_secs(0) {
  }

  virtual ~KillOptions() throw();
  int32_t wait_secs;

  _KillOptions__isset __isset;

  void __set_wait_secs(const int32_t val);

  bool operator == (const KillOptions & rhs) const
  {
    if (__isset.wait_secs != rhs.__isset.wait_secs)
      return false;
    else if (__isset.wait_secs && !(wait_secs == rhs.wait_secs))
      return false;
    return true;
  }
  bool operator != (const KillOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KillOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KillOptions& obj);
};

void swap(KillOptions &a, KillOptions &b);

typedef struct _RebalanceOptions__isset {
  _RebalanceOptions__isset() : wait_secs(false), num_workers(false), num_executors(false) {}
  bool wait_secs :1;
  bool num_workers :1;
  bool num_executors :1;
} _RebalanceOptions__isset;

class RebalanceOptions {
 public:

  static const char* ascii_fingerprint; // = "AE2BC96B4F638789D24A2539CC146D73";
  static const uint8_t binary_fingerprint[16]; // = {0xAE,0x2B,0xC9,0x6B,0x4F,0x63,0x87,0x89,0xD2,0x4A,0x25,0x39,0xCC,0x14,0x6D,0x73};

  RebalanceOptions(const RebalanceOptions&);
  RebalanceOptions& operator=(const RebalanceOptions&);
  RebalanceOptions() : wait_secs(0), num_workers(0) {
  }

  virtual ~RebalanceOptions() throw();
  int32_t wait_secs;
  int32_t num_workers;
  std::map<std::string, int32_t>  num_executors;

  _RebalanceOptions__isset __isset;

  void __set_wait_secs(const int32_t val);

  void __set_num_workers(const int32_t val);

  void __set_num_executors(const std::map<std::string, int32_t> & val);

  bool operator == (const RebalanceOptions & rhs) const
  {
    if (__isset.wait_secs != rhs.__isset.wait_secs)
      return false;
    else if (__isset.wait_secs && !(wait_secs == rhs.wait_secs))
      return false;
    if (__isset.num_workers != rhs.__isset.num_workers)
      return false;
    else if (__isset.num_workers && !(num_workers == rhs.num_workers))
      return false;
    if (__isset.num_executors != rhs.__isset.num_executors)
      return false;
    else if (__isset.num_executors && !(num_executors == rhs.num_executors))
      return false;
    return true;
  }
  bool operator != (const RebalanceOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RebalanceOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const RebalanceOptions& obj);
};

void swap(RebalanceOptions &a, RebalanceOptions &b);


class Credentials {
 public:

  static const char* ascii_fingerprint; // = "5EA2D527ECA3BA20C77AFC023EE8C05F";
  static const uint8_t binary_fingerprint[16]; // = {0x5E,0xA2,0xD5,0x27,0xEC,0xA3,0xBA,0x20,0xC7,0x7A,0xFC,0x02,0x3E,0xE8,0xC0,0x5F};

  Credentials(const Credentials&);
  Credentials& operator=(const Credentials&);
  Credentials() {
  }

  virtual ~Credentials() throw();
  std::map<std::string, std::string>  creds;

  void __set_creds(const std::map<std::string, std::string> & val);

  bool operator == (const Credentials & rhs) const
  {
    if (!(creds == rhs.creds))
      return false;
    return true;
  }
  bool operator != (const Credentials &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Credentials & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Credentials& obj);
};

void swap(Credentials &a, Credentials &b);

typedef struct _SubmitOptions__isset {
  _SubmitOptions__isset() : creds(false) {}
  bool creds :1;
} _SubmitOptions__isset;

class SubmitOptions {
 public:

  static const char* ascii_fingerprint; // = "DA594F6A0B85B6BF20BC2CDC85D9BD5F";
  static const uint8_t binary_fingerprint[16]; // = {0xDA,0x59,0x4F,0x6A,0x0B,0x85,0xB6,0xBF,0x20,0xBC,0x2C,0xDC,0x85,0xD9,0xBD,0x5F};

  SubmitOptions(const SubmitOptions&);
  SubmitOptions& operator=(const SubmitOptions&);
  SubmitOptions() : initial_status((TopologyInitialStatus::type)0) {
  }

  virtual ~SubmitOptions() throw();
  TopologyInitialStatus::type initial_status;
  Credentials creds;

  _SubmitOptions__isset __isset;

  void __set_initial_status(const TopologyInitialStatus::type val);

  void __set_creds(const Credentials& val);

  bool operator == (const SubmitOptions & rhs) const
  {
    if (!(initial_status == rhs.initial_status))
      return false;
    if (__isset.creds != rhs.__isset.creds)
      return false;
    else if (__isset.creds && !(creds == rhs.creds))
      return false;
    return true;
  }
  bool operator != (const SubmitOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SubmitOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SubmitOptions& obj);
};

void swap(SubmitOptions &a, SubmitOptions &b);

typedef struct _SupervisorInfo__isset {
  _SupervisorInfo__isset() : assignment_id(false), used_ports(false), meta(false), scheduler_meta(false), uptime_secs(false), version(false) {}
  bool assignment_id :1;
  bool used_ports :1;
  bool meta :1;
  bool scheduler_meta :1;
  bool uptime_secs :1;
  bool version :1;
} _SupervisorInfo__isset;

class SupervisorInfo {
 public:

  static const char* ascii_fingerprint; // = "026D38986C6CD678D38A8C1BB9EB4AE6";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0x6D,0x38,0x98,0x6C,0x6C,0xD6,0x78,0xD3,0x8A,0x8C,0x1B,0xB9,0xEB,0x4A,0xE6};

  SupervisorInfo(const SupervisorInfo&);
  SupervisorInfo& operator=(const SupervisorInfo&);
  SupervisorInfo() : time_secs(0), hostname(), assignment_id(), uptime_secs(0), version() {
  }

  virtual ~SupervisorInfo() throw();
  int64_t time_secs;
  std::string hostname;
  std::string assignment_id;
  std::vector<int64_t>  used_ports;
  std::vector<int64_t>  meta;
  std::map<std::string, std::string>  scheduler_meta;
  int64_t uptime_secs;
  std::string version;

  _SupervisorInfo__isset __isset;

  void __set_time_secs(const int64_t val);

  void __set_hostname(const std::string& val);

  void __set_assignment_id(const std::string& val);

  void __set_used_ports(const std::vector<int64_t> & val);

  void __set_meta(const std::vector<int64_t> & val);

  void __set_scheduler_meta(const std::map<std::string, std::string> & val);

  void __set_uptime_secs(const int64_t val);

  void __set_version(const std::string& val);

  bool operator == (const SupervisorInfo & rhs) const
  {
    if (!(time_secs == rhs.time_secs))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.assignment_id != rhs.__isset.assignment_id)
      return false;
    else if (__isset.assignment_id && !(assignment_id == rhs.assignment_id))
      return false;
    if (__isset.used_ports != rhs.__isset.used_ports)
      return false;
    else if (__isset.used_ports && !(used_ports == rhs.used_ports))
      return false;
    if (__isset.meta != rhs.__isset.meta)
      return false;
    else if (__isset.meta && !(meta == rhs.meta))
      return false;
    if (__isset.scheduler_meta != rhs.__isset.scheduler_meta)
      return false;
    else if (__isset.scheduler_meta && !(scheduler_meta == rhs.scheduler_meta))
      return false;
    if (__isset.uptime_secs != rhs.__isset.uptime_secs)
      return false;
    else if (__isset.uptime_secs && !(uptime_secs == rhs.uptime_secs))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const SupervisorInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SupervisorInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SupervisorInfo& obj);
};

void swap(SupervisorInfo &a, SupervisorInfo &b);


class NodeInfo {
 public:

  static const char* ascii_fingerprint; // = "A128A9539144C48C186510B7A4F4424B";
  static const uint8_t binary_fingerprint[16]; // = {0xA1,0x28,0xA9,0x53,0x91,0x44,0xC4,0x8C,0x18,0x65,0x10,0xB7,0xA4,0xF4,0x42,0x4B};

  NodeInfo(const NodeInfo&);
  NodeInfo& operator=(const NodeInfo&);
  NodeInfo() : node() {
  }

  virtual ~NodeInfo() throw();
  std::string node;
  std::set<int64_t>  port;

  void __set_node(const std::string& val);

  void __set_port(const std::set<int64_t> & val);

  bool operator == (const NodeInfo & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const NodeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const NodeInfo& obj);
};

void swap(NodeInfo &a, NodeInfo &b);

typedef struct _Assignment__isset {
  _Assignment__isset() : node_host(true), executor_node_port(true), executor_start_time_secs(true) {}
  bool node_host :1;
  bool executor_node_port :1;
  bool executor_start_time_secs :1;
} _Assignment__isset;

class Assignment {
 public:

  static const char* ascii_fingerprint; // = "BBFE89020174DAB392425A8D938F7199";
  static const uint8_t binary_fingerprint[16]; // = {0xBB,0xFE,0x89,0x02,0x01,0x74,0xDA,0xB3,0x92,0x42,0x5A,0x8D,0x93,0x8F,0x71,0x99};

  Assignment(const Assignment&);
  Assignment& operator=(const Assignment&);
  Assignment() : master_code_dir() {



  }

  virtual ~Assignment() throw();
  std::string master_code_dir;
  std::map<std::string, std::string>  node_host;
  std::map<std::vector<int64_t> , NodeInfo>  executor_node_port;
  std::map<std::vector<int64_t> , int64_t>  executor_start_time_secs;

  _Assignment__isset __isset;

  void __set_master_code_dir(const std::string& val);

  void __set_node_host(const std::map<std::string, std::string> & val);

  void __set_executor_node_port(const std::map<std::vector<int64_t> , NodeInfo> & val);

  void __set_executor_start_time_secs(const std::map<std::vector<int64_t> , int64_t> & val);

  bool operator == (const Assignment & rhs) const
  {
    if (!(master_code_dir == rhs.master_code_dir))
      return false;
    if (__isset.node_host != rhs.__isset.node_host)
      return false;
    else if (__isset.node_host && !(node_host == rhs.node_host))
      return false;
    if (__isset.executor_node_port != rhs.__isset.executor_node_port)
      return false;
    else if (__isset.executor_node_port && !(executor_node_port == rhs.executor_node_port))
      return false;
    if (__isset.executor_start_time_secs != rhs.__isset.executor_start_time_secs)
      return false;
    else if (__isset.executor_start_time_secs && !(executor_start_time_secs == rhs.executor_start_time_secs))
      return false;
    return true;
  }
  bool operator != (const Assignment &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Assignment & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Assignment& obj);
};

void swap(Assignment &a, Assignment &b);

typedef struct _TopologyActionOptions__isset {
  _TopologyActionOptions__isset() : kill_options(false), rebalance_options(false) {}
  bool kill_options :1;
  bool rebalance_options :1;
} _TopologyActionOptions__isset;

class TopologyActionOptions {
 public:

  static const char* ascii_fingerprint; // = "EB1DE4A673FEE1F37565E80190CFC8D6";
  static const uint8_t binary_fingerprint[16]; // = {0xEB,0x1D,0xE4,0xA6,0x73,0xFE,0xE1,0xF3,0x75,0x65,0xE8,0x01,0x90,0xCF,0xC8,0xD6};

  TopologyActionOptions(const TopologyActionOptions&);
  TopologyActionOptions& operator=(const TopologyActionOptions&);
  TopologyActionOptions() {
  }

  virtual ~TopologyActionOptions() throw();
  KillOptions kill_options;
  RebalanceOptions rebalance_options;

  _TopologyActionOptions__isset __isset;

  void __set_kill_options(const KillOptions& val);

  void __set_rebalance_options(const RebalanceOptions& val);

  bool operator == (const TopologyActionOptions & rhs) const
  {
    if (__isset.kill_options != rhs.__isset.kill_options)
      return false;
    else if (__isset.kill_options && !(kill_options == rhs.kill_options))
      return false;
    if (__isset.rebalance_options != rhs.__isset.rebalance_options)
      return false;
    else if (__isset.rebalance_options && !(rebalance_options == rhs.rebalance_options))
      return false;
    return true;
  }
  bool operator != (const TopologyActionOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TopologyActionOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TopologyActionOptions& obj);
};

void swap(TopologyActionOptions &a, TopologyActionOptions &b);

typedef struct _StormBase__isset {
  _StormBase__isset() : component_executors(false), launch_time_secs(false), owner(false), topology_action_options(false), prev_status(false) {}
  bool component_executors :1;
  bool launch_time_secs :1;
  bool owner :1;
  bool topology_action_options :1;
  bool prev_status :1;
} _StormBase__isset;

class StormBase {
 public:

  static const char* ascii_fingerprint; // = "727B1822C2E21CF690018861F654CD9E";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0x7B,0x18,0x22,0xC2,0xE2,0x1C,0xF6,0x90,0x01,0x88,0x61,0xF6,0x54,0xCD,0x9E};

  StormBase(const StormBase&);
  StormBase& operator=(const StormBase&);
  StormBase() : name(), status((TopologyStatus::type)0), num_workers(0), launch_time_secs(0), owner(), prev_status((TopologyStatus::type)0) {
  }

  virtual ~StormBase() throw();
  std::string name;
  TopologyStatus::type status;
  int32_t num_workers;
  std::map<std::string, int32_t>  component_executors;
  int32_t launch_time_secs;
  std::string owner;
  TopologyActionOptions topology_action_options;
  TopologyStatus::type prev_status;

  _StormBase__isset __isset;

  void __set_name(const std::string& val);

  void __set_status(const TopologyStatus::type val);

  void __set_num_workers(const int32_t val);

  void __set_component_executors(const std::map<std::string, int32_t> & val);

  void __set_launch_time_secs(const int32_t val);

  void __set_owner(const std::string& val);

  void __set_topology_action_options(const TopologyActionOptions& val);

  void __set_prev_status(const TopologyStatus::type val);

  bool operator == (const StormBase & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(num_workers == rhs.num_workers))
      return false;
    if (__isset.component_executors != rhs.__isset.component_executors)
      return false;
    else if (__isset.component_executors && !(component_executors == rhs.component_executors))
      return false;
    if (__isset.launch_time_secs != rhs.__isset.launch_time_secs)
      return false;
    else if (__isset.launch_time_secs && !(launch_time_secs == rhs.launch_time_secs))
      return false;
    if (__isset.owner != rhs.__isset.owner)
      return false;
    else if (__isset.owner && !(owner == rhs.owner))
      return false;
    if (__isset.topology_action_options != rhs.__isset.topology_action_options)
      return false;
    else if (__isset.topology_action_options && !(topology_action_options == rhs.topology_action_options))
      return false;
    if (__isset.prev_status != rhs.__isset.prev_status)
      return false;
    else if (__isset.prev_status && !(prev_status == rhs.prev_status))
      return false;
    return true;
  }
  bool operator != (const StormBase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StormBase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const StormBase& obj);
};

void swap(StormBase &a, StormBase &b);


class ClusterWorkerHeartbeat {
 public:

  static const char* ascii_fingerprint; // = "25E87DED9F0C4C2616358A3907530F4E";
  static const uint8_t binary_fingerprint[16]; // = {0x25,0xE8,0x7D,0xED,0x9F,0x0C,0x4C,0x26,0x16,0x35,0x8A,0x39,0x07,0x53,0x0F,0x4E};

  ClusterWorkerHeartbeat(const ClusterWorkerHeartbeat&);
  ClusterWorkerHeartbeat& operator=(const ClusterWorkerHeartbeat&);
  ClusterWorkerHeartbeat() : storm_id(), time_secs(0), uptime_secs(0) {
  }

  virtual ~ClusterWorkerHeartbeat() throw();
  std::string storm_id;
  std::map<ExecutorInfo, ExecutorStats>  executor_stats;
  int32_t time_secs;
  int32_t uptime_secs;

  void __set_storm_id(const std::string& val);

  void __set_executor_stats(const std::map<ExecutorInfo, ExecutorStats> & val);

  void __set_time_secs(const int32_t val);

  void __set_uptime_secs(const int32_t val);

  bool operator == (const ClusterWorkerHeartbeat & rhs) const
  {
    if (!(storm_id == rhs.storm_id))
      return false;
    if (!(executor_stats == rhs.executor_stats))
      return false;
    if (!(time_secs == rhs.time_secs))
      return false;
    if (!(uptime_secs == rhs.uptime_secs))
      return false;
    return true;
  }
  bool operator != (const ClusterWorkerHeartbeat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterWorkerHeartbeat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ClusterWorkerHeartbeat& obj);
};

void swap(ClusterWorkerHeartbeat &a, ClusterWorkerHeartbeat &b);


class ThriftSerializedObject {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  ThriftSerializedObject(const ThriftSerializedObject&);
  ThriftSerializedObject& operator=(const ThriftSerializedObject&);
  ThriftSerializedObject() : name(), bits() {
  }

  virtual ~ThriftSerializedObject() throw();
  std::string name;
  std::string bits;

  void __set_name(const std::string& val);

  void __set_bits(const std::string& val);

  bool operator == (const ThriftSerializedObject & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(bits == rhs.bits))
      return false;
    return true;
  }
  bool operator != (const ThriftSerializedObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftSerializedObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThriftSerializedObject& obj);
};

void swap(ThriftSerializedObject &a, ThriftSerializedObject &b);


class LocalStateData {
 public:

  static const char* ascii_fingerprint; // = "1594B7D6D740BD46400DEAE16650400E";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0x94,0xB7,0xD6,0xD7,0x40,0xBD,0x46,0x40,0x0D,0xEA,0xE1,0x66,0x50,0x40,0x0E};

  LocalStateData(const LocalStateData&);
  LocalStateData& operator=(const LocalStateData&);
  LocalStateData() {
  }

  virtual ~LocalStateData() throw();
  std::map<std::string, ThriftSerializedObject>  serialized_parts;

  void __set_serialized_parts(const std::map<std::string, ThriftSerializedObject> & val);

  bool operator == (const LocalStateData & rhs) const
  {
    if (!(serialized_parts == rhs.serialized_parts))
      return false;
    return true;
  }
  bool operator != (const LocalStateData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalStateData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LocalStateData& obj);
};

void swap(LocalStateData &a, LocalStateData &b);


class LocalAssignment {
 public:

  static const char* ascii_fingerprint; // = "D7FCE00ADD5FC34497CCD5C656555002";
  static const uint8_t binary_fingerprint[16]; // = {0xD7,0xFC,0xE0,0x0A,0xDD,0x5F,0xC3,0x44,0x97,0xCC,0xD5,0xC6,0x56,0x55,0x50,0x02};

  LocalAssignment(const LocalAssignment&);
  LocalAssignment& operator=(const LocalAssignment&);
  LocalAssignment() : topology_id() {
  }

  virtual ~LocalAssignment() throw();
  std::string topology_id;
  std::vector<ExecutorInfo>  executors;

  void __set_topology_id(const std::string& val);

  void __set_executors(const std::vector<ExecutorInfo> & val);

  bool operator == (const LocalAssignment & rhs) const
  {
    if (!(topology_id == rhs.topology_id))
      return false;
    if (!(executors == rhs.executors))
      return false;
    return true;
  }
  bool operator != (const LocalAssignment &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalAssignment & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LocalAssignment& obj);
};

void swap(LocalAssignment &a, LocalAssignment &b);


class LSSupervisorId {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  LSSupervisorId(const LSSupervisorId&);
  LSSupervisorId& operator=(const LSSupervisorId&);
  LSSupervisorId() : supervisor_id() {
  }

  virtual ~LSSupervisorId() throw();
  std::string supervisor_id;

  void __set_supervisor_id(const std::string& val);

  bool operator == (const LSSupervisorId & rhs) const
  {
    if (!(supervisor_id == rhs.supervisor_id))
      return false;
    return true;
  }
  bool operator != (const LSSupervisorId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LSSupervisorId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LSSupervisorId& obj);
};

void swap(LSSupervisorId &a, LSSupervisorId &b);


class LSApprovedWorkers {
 public:

  static const char* ascii_fingerprint; // = "91F548CA159B4AB4291F5741AC161402";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

  LSApprovedWorkers(const LSApprovedWorkers&);
  LSApprovedWorkers& operator=(const LSApprovedWorkers&);
  LSApprovedWorkers() {
  }

  virtual ~LSApprovedWorkers() throw();
  std::map<std::string, int32_t>  approved_workers;

  void __set_approved_workers(const std::map<std::string, int32_t> & val);

  bool operator == (const LSApprovedWorkers & rhs) const
  {
    if (!(approved_workers == rhs.approved_workers))
      return false;
    return true;
  }
  bool operator != (const LSApprovedWorkers &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LSApprovedWorkers & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LSApprovedWorkers& obj);
};

void swap(LSApprovedWorkers &a, LSApprovedWorkers &b);


class LSSupervisorAssignments {
 public:

  static const char* ascii_fingerprint; // = "F58E1204F94231D93CDA13ABA9C4F2B3";
  static const uint8_t binary_fingerprint[16]; // = {0xF5,0x8E,0x12,0x04,0xF9,0x42,0x31,0xD9,0x3C,0xDA,0x13,0xAB,0xA9,0xC4,0xF2,0xB3};

  LSSupervisorAssignments(const LSSupervisorAssignments&);
  LSSupervisorAssignments& operator=(const LSSupervisorAssignments&);
  LSSupervisorAssignments() {
  }

  virtual ~LSSupervisorAssignments() throw();
  std::map<int32_t, LocalAssignment>  assignments;

  void __set_assignments(const std::map<int32_t, LocalAssignment> & val);

  bool operator == (const LSSupervisorAssignments & rhs) const
  {
    if (!(assignments == rhs.assignments))
      return false;
    return true;
  }
  bool operator != (const LSSupervisorAssignments &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LSSupervisorAssignments & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LSSupervisorAssignments& obj);
};

void swap(LSSupervisorAssignments &a, LSSupervisorAssignments &b);


class LSWorkerHeartbeat {
 public:

  static const char* ascii_fingerprint; // = "D820B5AB4489A985D2D70D78E7DC465E";
  static const uint8_t binary_fingerprint[16]; // = {0xD8,0x20,0xB5,0xAB,0x44,0x89,0xA9,0x85,0xD2,0xD7,0x0D,0x78,0xE7,0xDC,0x46,0x5E};

  LSWorkerHeartbeat(const LSWorkerHeartbeat&);
  LSWorkerHeartbeat& operator=(const LSWorkerHeartbeat&);
  LSWorkerHeartbeat() : time_secs(0), topology_id(), port(0) {
  }

  virtual ~LSWorkerHeartbeat() throw();
  int32_t time_secs;
  std::string topology_id;
  std::vector<ExecutorInfo>  executors;
  int32_t port;

  void __set_time_secs(const int32_t val);

  void __set_topology_id(const std::string& val);

  void __set_executors(const std::vector<ExecutorInfo> & val);

  void __set_port(const int32_t val);

  bool operator == (const LSWorkerHeartbeat & rhs) const
  {
    if (!(time_secs == rhs.time_secs))
      return false;
    if (!(topology_id == rhs.topology_id))
      return false;
    if (!(executors == rhs.executors))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const LSWorkerHeartbeat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LSWorkerHeartbeat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LSWorkerHeartbeat& obj);
};

void swap(LSWorkerHeartbeat &a, LSWorkerHeartbeat &b);

typedef struct _GetInfoOptions__isset {
  _GetInfoOptions__isset() : num_err_choice(false) {}
  bool num_err_choice :1;
} _GetInfoOptions__isset;

class GetInfoOptions {
 public:

  static const char* ascii_fingerprint; // = "8C1740BBF54FD399631A4549952454DB";
  static const uint8_t binary_fingerprint[16]; // = {0x8C,0x17,0x40,0xBB,0xF5,0x4F,0xD3,0x99,0x63,0x1A,0x45,0x49,0x95,0x24,0x54,0xDB};

  GetInfoOptions(const GetInfoOptions&);
  GetInfoOptions& operator=(const GetInfoOptions&);
  GetInfoOptions() : num_err_choice((NumErrorsChoice::type)0) {
  }

  virtual ~GetInfoOptions() throw();
  NumErrorsChoice::type num_err_choice;

  _GetInfoOptions__isset __isset;

  void __set_num_err_choice(const NumErrorsChoice::type val);

  bool operator == (const GetInfoOptions & rhs) const
  {
    if (__isset.num_err_choice != rhs.__isset.num_err_choice)
      return false;
    else if (__isset.num_err_choice && !(num_err_choice == rhs.num_err_choice))
      return false;
    return true;
  }
  bool operator != (const GetInfoOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetInfoOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const GetInfoOptions& obj);
};

void swap(GetInfoOptions &a, GetInfoOptions &b);


class DRPCRequest {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  DRPCRequest(const DRPCRequest&);
  DRPCRequest& operator=(const DRPCRequest&);
  DRPCRequest() : func_args(), request_id() {
  }

  virtual ~DRPCRequest() throw();
  std::string func_args;
  std::string request_id;

  void __set_func_args(const std::string& val);

  void __set_request_id(const std::string& val);

  bool operator == (const DRPCRequest & rhs) const
  {
    if (!(func_args == rhs.func_args))
      return false;
    if (!(request_id == rhs.request_id))
      return false;
    return true;
  }
  bool operator != (const DRPCRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DRPCRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const DRPCRequest& obj);
};

void swap(DRPCRequest &a, DRPCRequest &b);


class DRPCExecutionException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  DRPCExecutionException(const DRPCExecutionException&);
  DRPCExecutionException& operator=(const DRPCExecutionException&);
  DRPCExecutionException() : msg() {
  }

  virtual ~DRPCExecutionException() throw();
  std::string msg;

  void __set_msg(const std::string& val);

  bool operator == (const DRPCExecutionException & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const DRPCExecutionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DRPCExecutionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const DRPCExecutionException& obj);
};

void swap(DRPCExecutionException &a, DRPCExecutionException &b);



#endif
